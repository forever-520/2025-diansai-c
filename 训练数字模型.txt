import cv2import numpy as npimport torchimport sysfrom pathlib import Path# YOLOv5相关导入YOLOV5_ROOT = Path(__file__).parentsys.path.append(str(YOLOV5_ROOT))from models.common import DetectMultiBackendfrom utils.general import non_max_suppression, check_img_sizefrom utils.torch_utils import select_devicefrom utils.plots import Annotator, colors# 帧宽和高度width = 640height = 480num = 1# YOLOv5模型全局变量yolo_model = Noneyolo_device = Noneyolo_imgsz = Noneyolo_class_names = None# YOLOv5核心函数def load_yolov5_model(weights_path, data_yaml, device=""):    """加载YOLOv5模型（训练尺寸640×640）"""    device = select_device(device)    model = DetectMultiBackend(weights_path, device=device, data=data_yaml)    stride = model.stride    imgsz = check_img_size(640, s=stride)  # 保持与训练一致的640×640    model.warmup(imgsz=(1, 3, imgsz, imgsz))    return model, device, imgsz, model.namesdef letterbox(img, new_shape=(640, 640), color=(114, 114, 114)):    """    带填充的缩放（保持原图宽高比）    与训练时的预处理完全一致，避免图像畸变    """    shape = img.shape[:2]  # 原图尺寸 (height, width)    if isinstance(new_shape, int):        new_shape = (new_shape, new_shape)    # 计算缩放比例（取宽高比中较小的比例，避免拉伸）    r = min(new_shape[0] / shape[0], new_shape[1] / shape[1])    # 计算缩放后的实际尺寸（保持比例）    new_unpad = (int(shape[1] * r), int(shape[0] * r))  # (width, height)    # 计算填充量（使最终尺寸为640×640，上下左右对称填充）    dw, dh = new_shape[1] - new_unpad[0], new_shape[0] - new_unpad[1]    dw /= 2  # 左右各填充一半    dh /= 2    # 缩放图像    img = cv2.resize(img, new_unpad, interpolation=cv2.INTER_LINEAR)    # 填充图像（上下左右补黑边，保持640×640）    top, bottom = int(round(dh - 0.1)), int(round(dh + 0.1))    left, right = int(round(dw - 0.1)), int(round(dw + 0.1))    img = cv2.copyMakeBorder(img, top, bottom, left, right, cv2.BORDER_CONSTANT, value=color)        return img, r, (dw, dh)  # 返回：填充后的图像、缩放比例、填充偏移量def detect_digits_with_yolo(frame):    """    使用YOLOv5模型检测图像中的数字    返回: [(数字值, 置信度, 中心坐标(x,y), 边界框(x1,y1,x2,y2)), ...]    """    global yolo_model, yolo_device, yolo_imgsz        if yolo_model is None:        print("YOLOv5模型未加载")        return []        try:        # 1. 图像预处理（640×480 -> 640×640）        img, ratio, (dw, dh) = letterbox(frame, new_shape=yolo_imgsz)        img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)        img_rgb = np.ascontiguousarray(img_rgb)                # 转换为模型输入格式        img_tensor = torch.from_numpy(img_rgb).permute(2, 0, 1).float() / 255.0        img_tensor = img_tensor.unsqueeze(0).to(yolo_device)        # 2. 模型推理        pred = yolo_model(img_tensor, augment=False, visualize=False)        pred = non_max_suppression(pred, conf_thres=0.25, iou_thres=0.45)        # 3. 处理检测结果        digit_results = []        for det in pred:            if len(det):                # 检测框坐标：先减去填充，再除以缩放比例，还原到原图尺寸                det[:, [0, 2]] -= dw  # x1, x2 减去左右填充                det[:, [1, 3]] -= dh  # y1, y2 减去上下填充                det[:, :4] /= ratio   # 除以缩放比例，得到原图坐标                                # 提取检测结果                for *xyxy, conf, cls in reversed(det):                    x1, y1, x2, y2 = [int(coord) for coord in xyxy]                    center_x = int((x1 + x2) / 2)                    center_y = int((y1 + y2) / 2)                    # 从类别索引映射到实际数字值                    cls_idx = int(cls)                    if cls_idx < len(yolo_class_names):                        digit_value = int(yolo_class_names[cls_idx])                    else:                        digit_value = cls_idx  # fallback                    confidence = float(conf)                                        digit_results.append((digit_value, confidence, (center_x, center_y), (x1, y1, x2, y2)))                print(f"YOLOv5检测到{len(digit_results)}个数字")        return digit_results            except Exception as e:        print(f"YOLOv5数字检测出错: {e}")        return []def associate_digit_labels_with_squares(squares_data, digit_results):    """    将YOLOv5检测到的数字标号与正方形进行关联    squares_data: [('square', contour, side_pixels, side_cm), ...]    digit_results: [(数字值, 置信度, 中心坐标, 边界框), ...]    返回: [(正方形轮廓, 实际边长像素, 实际边长cm, 数字标号, 置信度), ...]    """    associated_results = []        # 提取正方形信息    squares = []    for shape_data in squares_data:        if shape_data[0] == 'square':            _, contour, side_pixels, side_cm = shape_data[:4]            squares.append((contour, side_pixels, side_cm))        print(f"关联分析: {len(squares)}个正方形, {len(digit_results)}个数字")        # 为每个正方形寻找内部的数字标号    for square_idx, (square_contour, side_pixels, side_cm) in enumerate(squares):        associated_digit = None        best_confidence = 0                # 检查每个数字是否在当前正方形内        for digit_value, confidence, center, bbox in digit_results:            center_x, center_y = center                        # 使用cv2.pointPolygonTest检查点是否在正方形内            result = cv2.pointPolygonTest(square_contour, (center_x, center_y), False)                        if result >= 0:  # 点在多边形内部或边界上                if confidence > best_confidence:                    associated_digit = digit_value                    best_confidence = confidence                    print(f"正方形{square_idx}关联到数字{digit_value}(置信度{confidence:.3f})")                # 保存关联结果        if associated_digit is not None:            associated_results.append((square_contour, side_pixels, side_cm, associated_digit, best_confidence))            print(f"✓ 正方形{square_idx}: 标号{associated_digit}, 边长{side_cm:.2f}cm")        else:            # 没有关联数字的正方形，标号设为None            associated_results.append((square_contour, side_pixels, side_cm, None, 0))            print(f"✗ 正方形{square_idx}: 无标号, 边长{side_cm:.2f}cm")        return associated_results# 重置数字模板的函数def reset_digit_templates():    """重置数字模板，强制重新创建"""    global digit_templates    digit_templates = {}    print("数字模板已重置")# 创建标准数字模板def create_standard_digit_templates():    """创建标准的数字字体模板，不依赖当前图像"""    global digit_templates        if digit_templates:        return digit_templates        print("创建标准数字模板...")        # 多种模板尺寸，适配不同大小的正方形    template_sizes = [(20, 30), (25, 35), (30, 45), (35, 50), (40, 60)]    # 多种字体配置    font_configs = [        (cv2.FONT_HERSHEY_SIMPLEX, 0.8, 2),        (cv2.FONT_HERSHEY_SIMPLEX, 1.0, 2),        (cv2.FONT_HERSHEY_SIMPLEX, 1.2, 2),        (cv2.FONT_HERSHEY_DUPLEX, 0.8, 2),        (cv2.FONT_HERSHEY_COMPLEX, 0.7, 2)    ]        for digit in range(10):        templates_for_digit = []                # 为每个数字创建多种尺寸和字体的模板        for size_w, size_h in template_sizes:            for font, font_scale, thickness in font_configs:                # 创建黑色背景                template = np.zeros((size_h, size_w), dtype=np.uint8)                                # 获取文本大小并居中                text = str(digit)                text_size = cv2.getTextSize(text, font, font_scale, thickness)[0]                                x = (size_w - text_size[0]) // 2                y = (size_h + text_size[1]) // 2                                # 确保文本在模板内                if x >= 0 and y >= 0 and x + text_size[0] <= size_w:                    # 绘制白色数字                    cv2.putText(template, text, (x, y), font, font_scale, 255, thickness)                                        # 应用边缘检测，与目标图像保持一致                    edges = cv2.Canny(template, 50, 150)                                        if np.sum(edges) > 0:  # 确保模板不为空                        templates_for_digit.append(edges)                digit_templates[digit] = templates_for_digit        print(f"数字{digit}创建{len(templates_for_digit)}个标准模板")        print(f"标准数字模板创建完成，共{len(digit_templates)}个数字")    return digit_templates# 基于正方形检测的数字识别函数def recognize_digits_in_squares(gray_roi, inner_shapes, roi_offset=(0, 0)):    """    基于检测到的正方形内部进行数字识别    gray_roi: ROI区域的灰度图像    inner_shapes: 检测到的内部形状列表    roi_offset: ROI在原图中的偏移位置 (x, y)    """    # 确保标准模板已创建    create_standard_digit_templates()        recognition_results = []        # 从inner_shapes中提取正方形    squares = []    for shape_data in inner_shapes:        if shape_data[0] == 'square':  # 形状类型为正方形            if len(shape_data) >= 4:                _, contour, side_pixels, side_cm = shape_data[:4]            else:                _, contour, side_pixels = shape_data[:3]            squares.append(contour)        print(f"检测到{len(squares)}个正方形，开始内部数字识别...")        for square_idx, square_contour in enumerate(squares):        # 获取正方形的边界矩形        x, y, w, h = cv2.boundingRect(square_contour)                # 调整坐标（square_contour已经是相对于原图的坐标）        # 需要转换为相对于ROI的坐标        roi_x = x - roi_offset[0]        roi_y = y - roi_offset[1]                # 确保坐标在ROI范围内        roi_x = max(0, min(roi_x, gray_roi.shape[1] - w))        roi_y = max(0, min(roi_y, gray_roi.shape[0] - h))                # 添加小边距，避免包含正方形边框，只提取内部区域        margin = 3        inner_x = roi_x + margin        inner_y = roi_y + margin        inner_w = w - 2 * margin        inner_h = h - 2 * margin                # 确保内部区域有效        if inner_w <= 0 or inner_h <= 0:            print(f"正方形{square_idx}内部区域太小，跳过")            continue                # 提取正方形内部区域        digit_roi = gray_roi[inner_y:inner_y+inner_h, inner_x:inner_x+inner_w]                if digit_roi.size == 0:            print(f"正方形{square_idx}提取失败")            continue                # 对数字区域进行边缘检测        digit_edges = cv2.Canny(digit_roi, 40, 120)                print(f"正方形{square_idx}: 位置({roi_x},{roi_y}), 尺寸{w}x{h}, 内部区域{inner_w}x{inner_h}")                # 进行数字识别        best_digit = -1        best_confidence = 0.0        best_method = ""                # 对所有数字模板进行匹配        for digit in range(10):            templates_list = digit_templates[digit]                        for template_idx, template in enumerate(templates_list):                # 检查模板尺寸兼容性                if (template.shape[0] > digit_edges.shape[0] or                     template.shape[1] > digit_edges.shape[1]):                    continue                                try:                    # 模板匹配                    result = cv2.matchTemplate(digit_edges, template, cv2.TM_CCOEFF_NORMED)                    _, max_val, _, max_loc = cv2.minMaxLoc(result)                                        if max_val > best_confidence:                        best_confidence = max_val                        best_digit = digit                        best_method = f"标准模板{template_idx}"                                except cv2.error:                    continue                # 尝试尺寸归一化匹配        target_size = (30, 40)        try:            normalized_edges = cv2.resize(digit_edges, target_size)                        for digit in range(10):                templates_list = digit_templates[digit]                                for template_idx, template in enumerate(templates_list):                    if (template.shape[0] > target_size[1] or                         template.shape[1] > target_size[0]):                        continue                                        try:                        result = cv2.matchTemplate(normalized_edges, template, cv2.TM_CCOEFF_NORMED)                        _, max_val, _, max_loc = cv2.minMaxLoc(result)                                                # 归一化匹配略微降权                        adjusted_confidence = max_val * 0.95                                                if adjusted_confidence > best_confidence:                            best_confidence = adjusted_confidence                            best_digit = digit                            best_method = f"归一化模板{template_idx}"                                        except cv2.error:                        continue                except cv2.error:            pass                # 记录识别结果        confidence_threshold = 0.25  # 降低阈值        if best_confidence > confidence_threshold:            # 计算数字在原图中的位置            center_x = x + w // 2            center_y = y + h // 2            position = (center_x, center_y)                        # 返回相对于ROI的坐标用于显示            roi_rect = (inner_x, inner_y, inner_w, inner_h)                        recognition_results.append((best_digit, best_confidence, position, roi_rect, square_idx))            print(f"✓ 正方形{square_idx}识别成功: 数字{best_digit}, 置信度{best_confidence:.3f}, 方法:{best_method}")        else:            print(f"✗ 正方形{square_idx}识别失败, 最高置信度{best_confidence:.3f}")        print(f"正方形数字识别完成: 成功识别{len(recognition_results)}个")    return recognition_results# 简化图像预处理（只保留基本的灰度转换和二值化）def preprocess_frame(frame):    # RGB转灰度    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)        # 高斯滤波去噪（减少噪声影响）    blurred = cv2.GaussianBlur(gray, (5, 5), 2)        # 二值化处理，降低阈值保留内部白色区域    _, binary = cv2.threshold(blurred, 127, 220, cv2.THRESH_BINARY)        return gray, binary# 从边缘检测结果提取真实数字模板def extract_real_digit_templates_from_edges(edges_roi):    """    从边缘检测图像中自动提取数字1、2、3的真实轮廓作为模板    根据连通组件和位置信息推断数字标签    """    print("从边缘检测图像提取真实数字模板...")        # 使用连通组件分析获得更精确的区域分割    num_labels, labels, stats, centroids = cv2.connectedComponentsWithStats(edges_roi, connectivity=8)        digit_regions = []    for i in range(1, num_labels):  # 跳过背景(标签0)        x, y, w, h, area = stats[i]                # 过滤条件：合理的数字大小        if area > 50 and w > 8 and h > 12 and w < edges_roi.shape[1]*0.4 and h < edges_roi.shape[0]*0.6:            digit_regions.append((x, y, w, h, area, i))        # 按位置排序（从左到右，从上到下）    digit_regions.sort(key=lambda r: (r[1], r[0]))  # 按y坐标，再按x坐标        extracted_templates = {}    expected_digits = [1, 3, 2]  # 根据图像布局：1在左上，3在右上，2在下方        print(f"找到{len(digit_regions)}个候选数字区域")        for i, (x, y, w, h, area, label_id) in enumerate(digit_regions[:3]):        if i < len(expected_digits):            digit = expected_digits[i]                        # 提取该连通组件的像素            mask = (labels == label_id).astype(np.uint8) * 255                        # 提取数字区域，添加边距            margin = 3            x1, y1 = max(0, x-margin), max(0, y-margin)            x2, y2 = min(edges_roi.shape[1], x+w+margin), min(edges_roi.shape[0], y+h+margin)                        digit_template = mask[y1:y2, x1:x2]                        if digit_template.size > 0 and np.sum(digit_template) > 0:                extracted_templates[digit] = digit_template                print(f"成功提取数字{digit}模板，尺寸: {digit_template.shape}，面积: {area}")        return extracted_templates# 优化的混合数字模板创建函数def create_hybrid_digit_templates(sample_edges_roi=None, rectangles_info=None):    """    优化的混合策略创建数字模板：    1. 从边缘检测结果中提取真实数字轮廓作为主要模板    2. 用多种字体和参数补充模板库    3. 支持多尺度和变形模板    """    global digit_templates        # 如果模板已创建，直接返回    if digit_templates:        return digit_templates        print("开始创建优化的混合数字模板...")        # 第一步：从边缘检测图像提取真实模板    extracted_digits = {}    if sample_edges_roi is not None:        extracted_digits = extract_real_digit_templates_from_edges(sample_edges_roi)        # 第二步：创建字体渲染模板（多种尺寸和样式）    print("创建字体渲染数字模板...")        # 多种模板尺寸    template_sizes = [(25, 35), (30, 45), (35, 50), (40, 60), (45, 65)]    # 多种字体参数    font_configs = [        (cv2.FONT_HERSHEY_SIMPLEX, 1.0, 2),        (cv2.FONT_HERSHEY_SIMPLEX, 1.2, 2),        (cv2.FONT_HERSHEY_SIMPLEX, 1.5, 3),        (cv2.FONT_HERSHEY_DUPLEX, 1.0, 2),        (cv2.FONT_HERSHEY_COMPLEX, 0.8, 2)    ]        for digit in range(10):        templates_for_digit = []                # 如果有从边缘检测提取的模板，优先添加        if digit in extracted_digits:            real_template = extracted_digits[digit]            templates_for_digit.append(real_template)                        # 为真实模板创建多尺度版本            for scale in [0.8, 1.2, 1.5]:                if scale != 1.0:                    new_h, new_w = int(real_template.shape[0] * scale), int(real_template.shape[1] * scale)                    if new_h > 10 and new_w > 8:  # 确保尺寸合理                        scaled_template = cv2.resize(real_template, (new_w, new_h))                        templates_for_digit.append(scaled_template)                        print(f"数字{digit}使用提取的真实模板 + {len(templates_for_digit)-1}个缩放版本")                # 为每个数字创建多种字体和尺寸的模板        for size_w, size_h in template_sizes:            for font, font_scale, thickness in font_configs:                # 创建黑色背景                template = np.zeros((size_h, size_w), dtype=np.uint8)                                # 获取文本大小并居中                text = str(digit)                text_size = cv2.getTextSize(text, font, font_scale, thickness)[0]                                x = (size_w - text_size[0]) // 2                y = (size_h + text_size[1]) // 2                                # 确保文本在模板内                if x >= 0 and y >= 0 and x + text_size[0] <= size_w and y - text_size[1] >= 0:                    # 绘制白色数字                    cv2.putText(template, text, (x, y), font, font_scale, 255, thickness)                                        # 应用边缘检测                    edges = cv2.Canny(template, 50, 150)                                        if np.sum(edges) > 0:  # 确保模板不为空                        templates_for_digit.append(edges)                # 存储该数字的所有模板        digit_templates[digit] = templates_for_digit        print(f"数字{digit}共创建{len(templates_for_digit)}个模板")        print(f"优化混合数字模板创建完成，共{len(digit_templates)}个数字")    return digit_templates# 优化的数字识别函数def recognize_digits_from_edges(edges_roi, rectangles_info=None, confidence_threshold=0.3):    """    从边缘检测图像中识别数字（使用优化的混合模板和多种策略）    """    # 确保模板已创建（首次调用时提取当前图像的模板）    if not digit_templates:        create_hybrid_digit_templates(edges_roi, rectangles_info)        recognition_results = []        # 改进的区域分割：使用连通组件分析    print("使用连通组件分析进行区域分割...")    num_labels, labels, stats, centroids = cv2.connectedComponentsWithStats(edges_roi, connectivity=8)        digit_regions = []    for i in range(1, num_labels):  # 跳过背景(标签0)        x, y, w, h, area = stats[i]                # 优化的过滤条件        if (area > 30 and w > 6 and h > 10 and             w < edges_roi.shape[1]*0.6 and h < edges_roi.shape[0]*0.8 and            w/h < 3 and h/w < 4):  # 长宽比合理            digit_regions.append((x, y, w, h, area, i))        print(f"连通组件分析找到{len(digit_regions)}个候选数字区域")        # 对每个区域进行数字识别    for region_idx, (x, y, w, h, area, label_id) in enumerate(digit_regions):        # 提取该连通组件的像素作为数字区域        mask = (labels == label_id).astype(np.uint8) * 255        digit_roi = mask[y:y+h, x:x+w]                if digit_roi.size == 0 or np.sum(digit_roi) == 0:            continue                print(f"分析区域{region_idx}: 位置({x},{y}), 尺寸{w}x{h}, 面积{area}")                best_digit = -1        best_confidence = 0.0        best_method = ""                # 方法1: 直接模板匹配        for digit, templates_list in digit_templates.items():            for template_idx, template in enumerate(templates_list):                # 检查模板尺寸兼容性                if (template.shape[0] > digit_roi.shape[0] or                     template.shape[1] > digit_roi.shape[1]):                    continue                                try:                    # 模板匹配                    result = cv2.matchTemplate(digit_roi, template, cv2.TM_CCOEFF_NORMED)                    _, max_val, _, max_loc = cv2.minMaxLoc(result)                                        if max_val > best_confidence:                        best_confidence = max_val                        best_digit = digit                        best_method = f"直接匹配模板{template_idx}"                                except cv2.error:                    continue                # 方法2: 尺寸归一化后匹配        target_size = (40, 60)  # 标准化尺寸        try:            normalized_roi = cv2.resize(digit_roi, target_size)                        for digit, templates_list in digit_templates.items():                for template_idx, template in enumerate(templates_list):                    if template.shape[0] > target_size[1] or template.shape[1] > target_size[0]:                        continue                                        try:                        result = cv2.matchTemplate(normalized_roi, template, cv2.TM_CCOEFF_NORMED)                        _, max_val, _, max_loc = cv2.minMaxLoc(result)                                                # 归一化匹配的置信度稍微降权                        adjusted_confidence = max_val * 0.9                                                if adjusted_confidence > best_confidence:                            best_confidence = adjusted_confidence                            best_digit = digit                            best_method = f"归一化匹配模板{template_idx}"                                        except cv2.error:                        continue                except cv2.error:            pass                # 记录识别结果        if best_confidence > confidence_threshold:            position = (x + w//2, y + h//2)  # 数字中心位置            recognition_results.append((best_digit, best_confidence, position, (x, y, w, h)))            print(f"✓ 识别成功: 数字{best_digit}，置信度: {best_confidence:.3f}，方法: {best_method}")        else:            print(f"✗ 区域{region_idx}识别失败，最高置信度: {best_confidence:.3f}")        print(f"最终识别结果: 成功识别{len(recognition_results)}个数字")    return recognition_results# 矩形边框检测函数def detect_rectangles(binary):    # 查找轮廓（直接使用二值化图像）    contours, _ = cv2.findContours(binary, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)    rectangles = []    for contour in contours:        # 轮廓近似（使用更精确的参数）        epsilon = 0.015 * cv2.arcLength(contour, True)  # 降低epsilon获得更精确的近似        approx = cv2.approxPolyDP(contour, epsilon, True)                # 检查是否为4边形（矩形）        if len(approx) == 4:            # 获取矩形的边界框            rect = cv2.boundingRect(approx)            width, height = rect[2], rect[3]            area = width * height                        # 添加面积阈值判断（适合远距离检测）            min_area = 500  # 最小面积阈值            if area < min_area:                print(f"外围矩形被剔除: 面积{area}像素²小于阈值{min_area}")                continue                        # 计算长宽比            aspect_ratio = max(width, height) / min(width, height)                        # 设置有效的长宽比范围（1.0到2.5之间，更严格）            # 1.0是正方形，2.5是2.5:1的矩形            if 1.2 <= aspect_ratio <= 2.5:                # 计算四条边的长度                points = approx.reshape(-1, 2)                edge_lengths = []                for i in range(4):                    p1 = points[i]                    p2 = points[(i + 1) % 4]                    length = np.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)                    edge_lengths.append(length)                                # 检查对应边长是否相近（对边应该相等）                # 对边1和对边3，对边2和对边4                side1_diff = abs(edge_lengths[0] - edge_lengths[2]) / max(edge_lengths[0], edge_lengths[2])                side2_diff = abs(edge_lengths[1] - edge_lengths[3]) / max(edge_lengths[1], edge_lengths[3])                                # 对应边长差异阈值（更严格的10%以内认为合理）                edge_tolerance = 0.10                                if side1_diff <= edge_tolerance and side2_diff <= edge_tolerance:                    # 检查角度是否接近直角                    angles = []                    for i in range(4):                        p1 = points[i]                        p2 = points[(i + 1) % 4]                        p3 = points[(i + 2) % 4]                                                # 计算两个向量                        v1 = p1 - p2                        v2 = p3 - p2                                                # 计算角度                        cos_angle = np.dot(v1, v2) / (np.linalg.norm(v1) * np.linalg.norm(v2))                        cos_angle = np.clip(cos_angle, -1.0, 1.0)  # 防止数值误差                        angle_deg = np.degrees(np.arccos(abs(cos_angle)))                        angles.append(angle_deg)                                        # 检查所有角度是否接近90度（容差15度）                    angle_tolerance = 15.0                    valid_angles = all(abs(angle - 90.0) <= angle_tolerance for angle in angles)                                        if valid_angles:                        print(f"检测到有效矩形: 长宽比{aspect_ratio:.2f}, 边长差异{side1_diff:.3f}/{side2_diff:.3f}, 角度{angles}")                        rectangles.append(approx)                    else:                        print(f"矩形被剔除: 角度不是直角 {angles}")                else:                    print(f"矩形被剔除: 边长差异过大 {side1_diff:.3f}/{side2_diff:.3f} (阈值{edge_tolerance})")            else:                print(f"矩形被剔除: 长宽比{aspect_ratio:.2f}超出范围[1.0, 2.5]")        return rectangles# 计算像素到厘米的转换比例（基于内矩形）def calculate_pixel_to_cm_ratio_inner(rectangles):    """根据检测到的内矩形计算像素到厘米的转换比例"""    if len(rectangles) >= 2:        # 按面积排序，取较小的作为内边缘        rectangles_with_area = [(rect, cv2.contourArea(rect)) for rect in rectangles]        rectangles_with_area.sort(key=lambda x: x[1])        inner_rectangle = rectangles_with_area[0][0]  # 最小的矩形        print("使用内边缘矩形进行尺寸标定")    else:        inner_rectangle = rectangles[0]        print("使用单个矩形进行尺寸标定")        x, y, w, h = cv2.boundingRect(inner_rectangle)        # 内矩形标准尺寸（厘米）    INNER_WIDTH_CM = 16.5   # 内矩形宽度    INNER_HEIGHT_CM = 25  # 内矩形高度        # 计算像素到厘米的比例    pixel_to_cm_width = INNER_WIDTH_CM / w    pixel_to_cm_height = INNER_HEIGHT_CM / h    pixel_to_cm_ratio = (pixel_to_cm_width + pixel_to_cm_height) / 2        print(f"内矩形检测尺寸: {w}×{h} 像素")    print(f"内矩形标准尺寸: {INNER_WIDTH_CM}×{INNER_HEIGHT_CM} cm")    print(f"像素到厘米转换比例: {pixel_to_cm_ratio:.4f} cm/pixel")    print(f"宽度比例: {pixel_to_cm_width:.4f}, 高度比例: {pixel_to_cm_height:.4f}")        return pixel_to_cm_ratio# 内部基础图形检测函数def detect_inner_shapes(binary, rectangles):    """检测矩形内部的基础图形：圆形、正方形、三角形"""    all_shapes = []        # 计算像素到厘米转换比例    pixel_to_cm_ratio = calculate_pixel_to_cm_ratio_inner(rectangles)        # 如果有两个矩形，使用内边缘（较小的矩形）    if len(rectangles) >= 2:        # 按面积排序，取较小的作为内边缘        rectangles_with_area = [(rect, cv2.contourArea(rect)) for rect in rectangles]        rectangles_with_area.sort(key=lambda x: x[1])        target_rectangle = rectangles_with_area[0][0]  # 最小的矩形        print("检测到多个矩形，使用内边缘进行内部图形检测")    else:        target_rectangle = rectangles[0]        print("检测到单个矩形，直接进行内部图形检测")        # 提取ROI区域    x, y, w, h = cv2.boundingRect(target_rectangle)    roi_binary = binary[y:y+h, x:x+w]        # 在ROI内查找轮廓    contours, _ = cv2.findContours(roi_binary, cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)        print(f"在ROI内找到 {len(contours)} 个轮廓")        for i, contour in enumerate(contours):        area = cv2.contourArea(contour)                print(f"轮廓{i}: 面积{area}像素²")                # 过滤过小的轮廓（去除噪声）        if area < 100:            print(f"  -> 轮廓{i}被过滤: 面积太小({area} < 100)")            continue                    # 过滤边界轮廓（避免检测到矩形边界） - 使用很小的边界或不使用        contour_bbox = cv2.boundingRect(contour)        margin = 3  # 使用很小的边界值        if (contour_bbox[0] < margin or contour_bbox[1] < margin or            contour_bbox[0] + contour_bbox[2] > w - margin or            contour_bbox[1] + contour_bbox[3] > h - margin):            # 只过滤面积很大的边界轮廓（可能是矩形边界）            if area > w * h * 0.7:  # 只有当面积超过ROI的70%时才过滤                print(f"过滤大面积边界轮廓: 面积{area}像素²")                continue                # 轮廓近似获取顶点（放宽参数减少顶点数量）        epsilon = 0.042 * cv2.arcLength(contour, True)  # 增大epsilon减少顶点数量        approx = cv2.approxPolyDP(contour, epsilon, True)        vertices = len(approx)        perimeter = cv2.arcLength(contour, True)                print(f"  -> 轮廓{i}: {vertices}个顶点, 周长{perimeter:.1f}, epsilon={epsilon:.2f}")                # 调整坐标到原图        approx_adjusted = approx + [x, y]                # 三角形检测        if vertices == 3:            print(f"发现3个顶点的轮廓，面积{area}像素²，周长{perimeter:.1f}像素")            # 计算三条边的长度            points = approx.reshape(-1, 2)            side_lengths = []            for i in range(3):                p1 = points[i]                p2 = points[(i + 1) % 3]                length = np.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)                side_lengths.append(length)                        # 取平均边长            avg_side_pixels = int(np.mean(side_lengths))            avg_side_cm = avg_side_pixels * pixel_to_cm_ratio                        all_shapes.append(('triangle', approx_adjusted, avg_side_pixels, avg_side_cm))            print(f"检测到三角形: 平均边长{avg_side_pixels}像素 ({avg_side_cm:.2f}cm)")            continue                # 正方形/矩形检测        if vertices == 4:            rect_shape = cv2.boundingRect(approx)            width_rect, height_rect = rect_shape[2], rect_shape[3]            aspect_ratio = max(width_rect, height_rect) / min(width_rect, height_rect)                        # 检查是否为正方形（长宽比接近1）            if 0.7 <= aspect_ratio <= 1.4:                # 计算四条边的长度，取最短边                points = approx.reshape(-1, 2)                side_lengths = []                for i in range(4):                    p1 = points[i]                    p2 = points[(i + 1) % 4]                    length = np.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)                    side_lengths.append(length)                                # 取平均边长                avg_side_pixels = int(np.mean(side_lengths))                avg_side_cm = avg_side_pixels * pixel_to_cm_ratio                                all_shapes.append(('square', approx_adjusted, avg_side_pixels, avg_side_cm))                print(f"检测到正方形: 平均边长{avg_side_pixels}像素 ({avg_side_cm:.2f}cm)")                continue                # 圆形检测        if vertices >= 5:            circularity = 4 * np.pi * area / (perimeter * perimeter)            if 0.3 < circularity < 2.0:                # 使用轮廓的边界矩形计算更准确的圆形参数                rect_contour = cv2.boundingRect(contour)                center_x = rect_contour[0] + rect_contour[2] // 2 + x                center_y = rect_contour[1] + rect_contour[3] // 2 + y                center = (int(center_x), int(center_y))                                # 计算半径（取宽高的最小值）                radius = int(min(rect_contour[2], rect_contour[3]) / 2)                diameter_pixels = radius * 2                diameter_cm = diameter_pixels * pixel_to_cm_ratio                                # 保存原始轮廓用于更准确的绘制                contour_adjusted = contour + [x, y]                                all_shapes.append(('circle', center, radius, diameter_pixels, diameter_cm, contour_adjusted))                print(f"检测到圆形: 中心{center}, 半径{radius}像素, 直径{diameter_pixels}像素 ({diameter_cm:.2f}cm)")                continue        return all_shapes# 边缘检测和多边形逼近函数（增强版：包含凸凹角点区分和最短边长计算）def detect_internal_edges_and_polygons(gray, binary, rectangles, pixel_to_cm_ratio=None):    """对内部图形进行边缘检测，多边形逼近，显示顶点，区分凸凹角，计算最短边长"""    if not rectangles:        return []        # 确定目标矩形（内边缘或单个矩形）    if len(rectangles) >= 2:        rectangles_with_area = [(rect, cv2.contourArea(rect)) for rect in rectangles]        rectangles_with_area.sort(key=lambda x: x[1])        target_rectangle = rectangles_with_area[0][0]        print("使用内边缘矩形进行内部图形边缘检测")    else:        target_rectangle = rectangles[0]        print("使用单个矩形进行内部图形边缘检测")        # 提取ROI区域    x, y, w, h = cv2.boundingRect(target_rectangle)    roi_gray = gray[y:y+h, x:x+w]    roi_binary = binary[y:y+h, x:x+w]        # 边缘检测    edges = cv2.Canny(roi_gray, 50, 150)        # 形态学操作清理边缘    kernel = np.ones((3,3), np.uint8)    edges = cv2.morphologyEx(edges, cv2.MORPH_CLOSE, kernel)        # 查找轮廓    contours, _ = cv2.findContours(edges, cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)        detected_polygons = []        print(f"在ROI内找到 {len(contours)} 个边缘轮廓")        for i, contour in enumerate(contours):        area = cv2.contourArea(contour)        perimeter = cv2.arcLength(contour, True)                print(f"边缘轮廓{i}: 面积{area}像素², 周长{perimeter:.1f}像素")                # 过滤过小的轮廓        if area < 200:            print(f"  -> 轮廓{i}被过滤: 面积太小({area} < 200)")            continue                    # 过滤边界轮廓        contour_bbox = cv2.boundingRect(contour)        margin = 5        if (contour_bbox[0] < margin or contour_bbox[1] < margin or            contour_bbox[0] + contour_bbox[2] > w - margin or            contour_bbox[1] + contour_bbox[3] > h - margin):            if area > w * h * 0.6:  # 只过滤大面积边界轮廓                print(f"  -> 轮廓{i}被过滤: 大面积边界轮廓({area} > {w * h * 0.6:.0f})")                continue                # 多边形逼近        epsilon = 0.02 * cv2.arcLength(contour, True)        approx = cv2.approxPolyDP(contour, epsilon, True)        vertices = len(approx)                print(f"  -> 多边形逼近: {vertices}个顶点")                # 初始化变量        min_edge_length = float('inf')        min_edge_pair = None        min_edge_length_cm = 0        convex_corners = []        concave_corners = []                # 只对有足够顶点的多边形进行角点分析        if vertices >= 4:            # ===== 凸凹角点区分分析 =====            corners_local = []            for point in approx:                corner_x = point[0][0]                corner_y = point[0][1]                corners_local.append((corner_x, corner_y))                        # 分析凸角点和凹角点（学习参考文件的方法）            for j in range(vertices):                # 获取相邻三个点                p1 = corners_local[(j-1) % vertices]                p2 = corners_local[j]  # 当前角点                p3 = corners_local[(j+1) % vertices]                                # 计算向量                v1 = (p1[0] - p2[0], p1[1] - p2[1])                v2 = (p3[0] - p2[0], p3[1] - p2[1])                                # 计算叉积判断凸凹性                cross_product = v1[0] * v2[1] - v1[1] * v2[0]                                if cross_product > 0:  # 凸角点                    convex_corners.append((p2, j))                else:  # 凹角点                    concave_corners.append((p2, j))                        print(f"    角点分析: {len(convex_corners)}个凸角点, {len(concave_corners)}个凹角点")                        # ===== 计算相邻凸角点间的最短边长（沿轮廓边缘） =====                        if len(convex_corners) >= 2:                # 使用原始轮廓点而不是近似的多边形点来确保沿着真实轮廓边缘                original_contour_points = contour.reshape(-1, 2)                sorted_convex_corners = []                                for corner, corner_idx in convex_corners:                    # 在原始轮廓中找到最接近的点索引                    min_dist = float('inf')                    best_idx = -1                    for idx, contour_point in enumerate(original_contour_points):                        dist = ((corner[0] - contour_point[0])**2 + (corner[1] - contour_point[1])**2)**0.5                        if dist < min_dist:                            min_dist = dist                            best_idx = idx                    if best_idx != -1:                        sorted_convex_corners.append((corner, best_idx))                                # 按轮廓索引排序                sorted_convex_corners.sort(key=lambda x: x[1])                                # 将所有角点（凸角点和凹角点）按轮廓顺序排序                all_corners = []                for corner, corner_idx in convex_corners:                    best_idx = -1                    min_dist = float('inf')                    for idx, contour_point in enumerate(original_contour_points):                        dist = ((corner[0] - contour_point[0])**2 + (corner[1] - contour_point[1])**2)**0.5                        if dist < min_dist:                            min_dist = dist                            best_idx = idx                    if best_idx != -1:                        all_corners.append(('convex', corner, best_idx))                                for corner, corner_idx in concave_corners:                    best_idx = -1                    min_dist = float('inf')                    for idx, contour_point in enumerate(original_contour_points):                        dist = ((corner[0] - contour_point[0])**2 + (corner[1] - contour_point[1])**2)**0.5                        if dist < min_dist:                            min_dist = dist                            best_idx = idx                    if best_idx != -1:                        all_corners.append(('concave', corner, best_idx))                                # 按轮廓索引排序所有角点                all_corners.sort(key=lambda x: x[2])                                # 计算相邻凸角点间的边长（只有直接相邻的凸角点才能连接）                convex_corner_indices = []                for i, (corner_type, corner, idx) in enumerate(all_corners):                    if corner_type == 'convex':                        convex_corner_indices.append(i)                                print(f"    按顺序排列的角点: {[f'{corner_type[0].upper()}{i}' for i, (corner_type, _, _) in enumerate(all_corners)]}")                print(f"    凸角点在序列中的位置: {convex_corner_indices}")                                # 只计算在角点序列中直接相邻的凸角点之间的边长                for i in range(len(convex_corner_indices)):                    current_convex_idx = convex_corner_indices[i]                    next_convex_idx = convex_corner_indices[(i + 1) % len(convex_corner_indices)]                                        # 检查两个凸角点之间是否直接相邻（中间没有其他角点）                    is_adjacent = False                    if next_convex_idx == current_convex_idx + 1:  # 顺序相邻                        is_adjacent = True                    elif current_convex_idx == len(all_corners) - 1 and next_convex_idx == 0:  # 环形相邻                        is_adjacent = True                                        if is_adjacent:                        corner1_type, corner1, idx1 = all_corners[current_convex_idx]                        corner2_type, corner2, idx2 = all_corners[next_convex_idx]                                                # 计算沿轮廓的路径长度（两个方向都计算，取较短的）                        # 方向1：正向遍历                        path_length_forward = 0                        current_idx = idx1                        step_count = 0                                                while current_idx != idx2 and step_count < len(original_contour_points):                            next_idx = (current_idx + 1) % len(original_contour_points)                            p1 = original_contour_points[current_idx]                            p2 = original_contour_points[next_idx]                            path_length_forward += ((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)**0.5                            current_idx = next_idx                            step_count += 1                                                # 方向2：反向遍历                        path_length_backward = 0                        current_idx = idx1                        step_count = 0                                                while current_idx != idx2 and step_count < len(original_contour_points):                            prev_idx = (current_idx - 1) % len(original_contour_points)                            p1 = original_contour_points[current_idx]                            p2 = original_contour_points[prev_idx]                            path_length_backward += ((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)**0.5                            current_idx = prev_idx                            step_count += 1                                                # 选择较短的路径                        path_length = min(path_length_forward, path_length_backward)                                                if path_length < min_edge_length and path_length > 0:                            min_edge_length = path_length                            min_edge_pair = (corner1, corner2)                            min_edge_length_cm = min_edge_length * pixel_to_cm_ratio if pixel_to_cm_ratio else 0                            print(f"    找到相邻凸角点边: {corner1} -> {corner2}, 长度: {path_length:.1f}px ({min_edge_length_cm:.2f}cm)")                                if min_edge_pair:                    print(f"    最短凸角点边长(沿轮廓): {min_edge_length:.1f}像素 ({min_edge_length_cm:.2f}cm)")                    print(f"    最短凸角点对: {min_edge_pair[0]} <-> {min_edge_pair[1]}")                # 调整坐标到原图        approx_adjusted = approx + [x, y]                # 计算边长（用于尺寸估算）        points = approx.reshape(-1, 2)        side_lengths = []        for j in range(vertices):            p1 = points[j]            p2 = points[(j + 1) % vertices]            length = np.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)            side_lengths.append(length)                if side_lengths:            avg_side_pixels = int(np.mean(side_lengths))            max_side_pixels = int(max(side_lengths))            avg_side_cm = avg_side_pixels * pixel_to_cm_ratio if pixel_to_cm_ratio else 0            max_side_cm = max_side_pixels * pixel_to_cm_ratio if pixel_to_cm_ratio else 0                        # 调整凸角点坐标到原图            convex_corners_adjusted = []            concave_corners_adjusted = []            if vertices >= 4:                for (corner, idx) in convex_corners:                    convex_corners_adjusted.append(((corner[0] + x, corner[1] + y), idx))                for (corner, idx) in concave_corners:                    concave_corners_adjusted.append(((corner[0] + x, corner[1] + y), idx))                        # 调整最短边长端点坐标到原图            min_edge_pair_adjusted = None            if min_edge_pair:                corner1, corner2 = min_edge_pair                min_edge_pair_adjusted = (                    (corner1[0] + x, corner1[1] + y),                    (corner2[0] + x, corner2[1] + y)                )                        detected_polygons.append({                'vertices': vertices,                'contour': approx_adjusted,                'area': area,                'perimeter': perimeter,                'avg_side_pixels': avg_side_pixels,                'max_side_pixels': max_side_pixels,                'avg_side_cm': avg_side_cm,                'max_side_cm': max_side_cm,                'side_lengths': side_lengths,                'convex_corners': convex_corners_adjusted,                'concave_corners': concave_corners_adjusted,                'min_edge_length': min_edge_length,                'min_edge_length_cm': min_edge_length_cm,                'min_edge_pair': min_edge_pair_adjusted            })                        print(f"  -> 检测到多边形: {vertices}顶点, 平均边长{avg_side_pixels}px ({avg_side_cm:.2f}cm)")        return detected_polygons# 多边形角点检测函数（借鉴参考文件的角点检测方法）def detect_polygon_corners(gray, rectangle, pixel_to_cm_ratio=None):    # 提取ROI区域    x, y, w, h = cv2.boundingRect(rectangle)    roi_gray = gray[y:y+h, x:x+w]        polygons = []        # 直接用Canny边缘检测（与基础检测相同参数）    edges_roi = cv2.Canny(roi_gray, 50, 150)    contours, _ = cv2.findContours(edges_roi, cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)        roi_area = w * h        for contour in contours:        area = cv2.contourArea(contour)                # 过滤太小和太大的轮廓（重点：过滤外边框）        if area < 200 or area > roi_area * 0.7:            continue                # 额外过滤：检查轮廓是否靠近边界（排除外边框）        x_contour, y_contour, w_contour, h_contour = cv2.boundingRect(contour)        margin = 10        if (x_contour < margin or y_contour < margin or             x_contour + w_contour > roi_gray.shape[1] - margin or             y_contour + h_contour > roi_gray.shape[0] - margin):            continue                # 轮廓近似获取角点        epsilon = 0.015 * cv2.arcLength(contour, True)        approx = cv2.approxPolyDP(contour, epsilon, True)                # 调整坐标到原图        corners = []        for point in approx:            corner_x = point[0][0] + x            corner_y = point[0][1] + y            corners.append((corner_x, corner_y))                vertices = len(corners)                # 检测重叠正方形和多边形        if vertices >= 4:            # 分析凸角点和凹角点            convex_corners = []            concave_corners = []                        for i in range(vertices):                # 获取相邻三个点                p1 = corners[(i-1) % vertices]                p2 = corners[i]  # 当前角点                p3 = corners[(i+1) % vertices]                                # 计算向量                v1 = (p1[0] - p2[0], p1[1] - p2[1])                v2 = (p3[0] - p2[0], p3[1] - p2[1])                                # 计算叉积判断凸凹性                cross_product = v1[0] * v2[1] - v1[1] * v2[0]                                if cross_product > 0:  # 凸角点                    convex_corners.append((p2, i))                else:  # 凹角点                    concave_corners.append((p2, i))                        print(f"角点分析: {len(convex_corners)}个凸角点, {len(concave_corners)}个凹角点")                        # 寻找相邻凸角点之间的最小距离            min_distance = float('inf')            min_pair = None                        if len(convex_corners) >= 2:                for i in range(len(convex_corners)):                    for j in range(i+1, len(convex_corners)):                        p1, idx1 = convex_corners[i]                        p2, idx2 = convex_corners[j]                                                # 计算距离                        distance = ((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)**0.5                                                # 检查是否为相邻的凸角点                        idx_diff = abs(idx1 - idx2)                        is_adjacent = (idx_diff == 1 or idx_diff == vertices - 1 or idx_diff <= 2)                                                if is_adjacent and distance < min_distance:                            min_distance = distance                            min_pair = (p1, p2)                        if min_pair:                min_distance_cm = min_distance * pixel_to_cm_ratio if pixel_to_cm_ratio else 0                print(f"最小凸角点距离: {min_distance:.1f}像素 ({min_distance_cm:.2f}cm)")                print(f"最小凸角点对: {min_pair[0]} <-> {min_pair[1]}")                        # 根据图形类型进行处理            if vertices == 4:                # 检查是否为正方形（重叠正方形检测）                rect_shape = cv2.boundingRect(approx)                aspect_ratio = rect_shape[2] / rect_shape[3]                if 0.7 <= aspect_ratio <= 1.3:                    # 计算四条边的长度，取最短边                    points = approx.reshape(-1, 2)                    side_lengths = []                    for i in range(4):                        p1 = points[i]                        p2 = points[(i + 1) % 4]                        length = np.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)                        side_lengths.append(length)                                        # 取最短边长                    min_side_pixels = int(min(side_lengths))                    min_side_cm = min_side_pixels * pixel_to_cm_ratio if pixel_to_cm_ratio else 0                                        if min_side_cm >= 3.0 or pixel_to_cm_ratio is None:                        polygons.append(('square', corners, vertices, area, min_side_pixels, min_side_cm, convex_corners, concave_corners))                        print(f"重叠正方形检测: 最短边长{min_side_pixels}像素({min_side_cm:.1f}cm)，面积{area:.0f}")                    else:                        print(f"重叠正方形被剔除: 最短边长{min_side_cm:.1f}cm小于3cm")        # 找到最小的图形（按边长排序）    if polygons:        smallest_polygon = min(polygons, key=lambda p: p[4])  # 按边长排序        _, corners, vertices, area, side_pixels, side_cm, convex_corners, concave_corners = smallest_polygon        print(f"检测到最小重叠正方形: 最短边长{side_pixels}像素({side_cm:.1f}cm)，角点坐标: {corners}")        return [('square', corners, side_pixels, side_cm)]        print("未检测到重叠的正方形")    return []# 显示内部图形检测处理步骤def show_inner_shapes_detection_steps(frame, gray, binary, rectangles, inner_shapes):    """    显示内部图形检测的完整处理步骤    步骤1: 原始图像    步骤2: 矩形检测结果    步骤3: ROI提取    步骤4: 轮廓检测    步骤5: 形状分类    步骤6: 最终结果    """    if not rectangles:        return frame        # 确定目标矩形（内边缘或单个矩形）    if len(rectangles) >= 2:        rectangles_with_area = [(rect, cv2.contourArea(rect)) for rect in rectangles]        rectangles_with_area.sort(key=lambda x: x[1])        target_rectangle = rectangles_with_area[0][0]    else:        target_rectangle = rectangles[0]        x, y, w, h = cv2.boundingRect(target_rectangle)    roi_binary = binary[y:y+h, x:x+w]    roi_gray = gray[y:y+h, x:x+w]        # 步骤1: 原始图像    step1 = cv2.resize(frame, (320, 240))        # 步骤2: 矩形检测结果    step2_img = frame.copy()    for rect in rectangles:        cv2.drawContours(step2_img, [rect], -1, (0, 255, 0), 1)    # 高亮目标矩形    cv2.drawContours(step2_img, [target_rectangle], -1, (0, 255, 255), 2)    step2 = cv2.resize(step2_img, (320, 240))        # 步骤3: ROI提取    step3 = cv2.resize(cv2.cvtColor(roi_gray, cv2.COLOR_GRAY2BGR), (320, 240))        # 步骤4: 二值化结果    step4_img = cv2.cvtColor(roi_binary, cv2.COLOR_GRAY2BGR)    step4 = cv2.resize(step4_img, (320, 240))        # 步骤5: 基于正方形的数字识别    # 使用标准边缘检测参数    edges_roi = cv2.Canny(roi_gray, 40, 120)    step5_img = cv2.cvtColor(edges_roi, cv2.COLOR_GRAY2BGR)        # 使用新的基于正方形的数字识别方法    digit_results = recognize_digits_in_squares(roi_gray, inner_shapes, roi_offset=(x, y))    print(f"基于正方形识别到{len(digit_results)}个数字")        # 在边缘检测图像上叠加识别结果    for digit, confidence, position, (dx, dy, dw, dh), square_idx in digit_results:        # 绘制识别框（相对于ROI坐标）        cv2.rectangle(step5_img, (dx, dy), (dx+dw, dy+dh), (0, 255, 0), 1)                # 显示识别的数字和置信度        text = f"{digit}({confidence:.2f})"        cv2.putText(step5_img, text, (dx, dy-5),                    cv2.FONT_HERSHEY_SIMPLEX, 0.4, (0, 255, 255), 1)                # 显示正方形编号        cv2.putText(step5_img, f"S{square_idx}", (dx+dw-15, dy+dh-5),                    cv2.FONT_HERSHEY_SIMPLEX, 0.3, (255, 255, 0), 1)        step5 = cv2.resize(step5_img, (320, 240))        # 步骤6: 形状分类    contours, _ = cv2.findContours(roi_binary, cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)    step6_img = cv2.cvtColor(roi_gray, cv2.COLOR_GRAY2BGR)    for contour in contours:        area = cv2.contourArea(contour)        if area < 100:            continue                contour_bbox = cv2.boundingRect(contour)        margin = 5        if (contour_bbox[0] < margin or contour_bbox[1] < margin or            contour_bbox[0] + contour_bbox[2] > w - margin or            contour_bbox[1] + contour_bbox[3] > h - margin):            continue                epsilon = 0.04 * cv2.arcLength(contour, True)  # 与检测函数保持一致        approx = cv2.approxPolyDP(contour, epsilon, True)        vertices = len(approx)        perimeter = cv2.arcLength(contour, True)                # 根据形状类型用不同颜色绘制        if vertices > 6:            circularity = 4 * np.pi * area / (perimeter * perimeter)            if 0.3 < circularity < 2.0:                cv2.drawContours(step6_img, [contour], -1, (255, 0, 0), 1)  # 蓝色圆形            else:                cv2.drawContours(step6_img, [contour], -1, (0, 165, 255), 1)  # 橙色多边形        elif vertices == 3:            cv2.drawContours(step6_img, [contour], -1, (255, 0, 255), 1)  # 紫色三角形        elif vertices == 4:            rect_shape = cv2.boundingRect(approx)            width_rect, height_rect = rect_shape[2], rect_shape[3]            aspect_ratio = max(width_rect, height_rect) / min(width_rect, height_rect)            if 0.7 <= aspect_ratio <= 1.4:                cv2.drawContours(step6_img, [contour], -1, (0, 0, 255), 1)  # 红色正方形            else:                cv2.drawContours(step6_img, [contour], -1, (0, 165, 255), 1)  # 橙色多边形        else:            cv2.drawContours(step6_img, [contour], -1, (0, 165, 255), 1)  # 橙色多边形        step6 = cv2.resize(step6_img, (320, 240))        # 步骤7: 最终结果    step7 = frame.copy()    for rect in rectangles:        cv2.drawContours(step7, [rect], -1, (0, 255, 0), 1)        # 绘制内部图形    for shape_data in inner_shapes:        shape_type = shape_data[0]        if shape_type == 'circle':            if len(shape_data) >= 6:                _, center, radius, diameter_pixels, diameter_cm, contour_adjusted = shape_data                cv2.drawContours(step7, [contour_adjusted], -1, (255, 0, 0), 1)                cv2.circle(step7, center, 2, (255, 0, 0), -1)            else:                _, center, radius, diameter_pixels = shape_data                cv2.circle(step7, center, radius, (255, 0, 0), 1)                cv2.circle(step7, center, 2, (255, 0, 0), -1)        elif shape_type == 'square':            if len(shape_data) >= 4:                _, contour, side_pixels, side_cm = shape_data            else:                _, contour, side_pixels = shape_data            cv2.drawContours(step7, [contour], -1, (0, 0, 255), 1)        elif shape_type == 'triangle':            if len(shape_data) >= 4:                _, contour, side_pixels, side_cm = shape_data            else:                _, contour, side_pixels = shape_data            cv2.drawContours(step7, [contour], -1, (255, 0, 255), 1)        elif shape_type == 'polygon':            if len(shape_data) >= 5:                _, contour, vertices, side_pixels, side_cm = shape_data            else:                _, contour, vertices, side_pixels = shape_data            cv2.drawContours(step7, [contour], -1, (0, 165, 255), 1)            # 绘制角点            for point in contour:                center = tuple(point[0])                cv2.circle(step7, center, 1, (0, 255, 0), -1)        # 在最终结果中也显示数字识别结果    for digit, confidence, position, (dx, dy, dw, dh), square_idx in digit_results:        # 将ROI坐标转换回原图坐标        abs_x, abs_y = x + dx, y + dy        abs_w, abs_h = dw, dh                # 绘制识别框        cv2.rectangle(step7, (abs_x, abs_y), (abs_x+abs_w, abs_y+abs_h), (0, 255, 0), 2)                # 显示识别的数字        text = f"Digit: {digit} ({confidence:.2f})"        cv2.putText(step7, text, (abs_x, abs_y-10),                    cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 255, 255), 2)        step7 = cv2.resize(step7, (320, 240))        # 拼接所有步骤 (重新安排为2行显示)    # 第一行：原图、矩形检测、ROI提取、二值化    top_row = np.hstack((step1, step2, step3, step4))    # 第二行：边缘检测、形状分类、最终结果、空白    empty_step = np.zeros((240, 320, 3), dtype=np.uint8)    bottom_row = np.hstack((step5, step6, step7, empty_step))        combined = np.vstack((top_row, bottom_row))        # 添加步骤标题    cv2.putText(combined, "1.Original", (10, 20), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 2)    cv2.putText(combined, "2.Rectangle Detection", (330, 20), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 2)    cv2.putText(combined, "3.ROI Extraction", (650, 20), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 2)    cv2.putText(combined, "4.Binarization", (970, 20), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 2)    cv2.putText(combined, "5.Square Digit Recognition", (10, 260), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 2)    cv2.putText(combined, "6.Shape Classification", (330, 260), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 2)    cv2.putText(combined, "7.Final Result", (650, 260), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 2)        return combined# 检测倾斜的A4纸边框函数（用于发挥题4）def detect_tilted_a4_paper(binary):    """    检测倾斜的A4纸边框，返回四个角点坐标    使用更宽松的参数来适应倾斜场景    """    print("检测倾斜A4纸边框...")        # 查找轮廓    contours, _ = cv2.findContours(binary, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)        if not contours:        print("未找到任何轮廓")        return None        # 按面积排序，取最大的几个轮廓    contours = sorted(contours, key=cv2.contourArea, reverse=True)        for i, contour in enumerate(contours[:5]):  # 检查前5个最大轮廓        area = cv2.contourArea(contour)                # 面积过滤 - 倾斜的A4纸面积会变化，使用更宽松的阈值        min_area = 10000  # 降低最小面积要求        max_area = binary.shape[0] * binary.shape[1] * 0.8  # 最大面积80%                if area < min_area or area > max_area:            continue                print(f"检查轮廓{i}: 面积{area}像素²")                # 轮廓近似 - 使用更宽松的epsilon值        epsilon = 0.02 * cv2.arcLength(contour, True)  # 增大epsilon值        approx = cv2.approxPolyDP(contour, epsilon, True)                # 检查是否为四边形        if len(approx) == 4:            # 获取四个顶点            points = approx.reshape(-1, 2)                        # 检查是否形成合理的四边形（不需要严格的直角要求）            # 计算四条边的长度            edge_lengths = []            for j in range(4):                p1 = points[j]                p2 = points[(j + 1) % 4]                length = np.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)                edge_lengths.append(length)                        # 检查对边长度是否相近（倾斜后仍应保持）            side1_ratio = min(edge_lengths[0], edge_lengths[2]) / max(edge_lengths[0], edge_lengths[2])            side2_ratio = min(edge_lengths[1], edge_lengths[3]) / max(edge_lengths[1], edge_lengths[3])                        # 放宽对边长度要求，倾斜会造成透视变形            if side1_ratio > 0.6 and side2_ratio > 0.6:                # 计算四边形的凸性（确保是凸四边形）                hull = cv2.convexHull(points)                hull_area = cv2.contourArea(hull)                contour_area = cv2.contourArea(approx)                                if abs(hull_area - contour_area) / contour_area < 0.1:  # 接近凸四边形                    print(f"✓ 找到倾斜A4纸: 面积{area}像素², 对边比例{side1_ratio:.3f}/{side2_ratio:.3f}")                                        # 对四个角点进行排序：左上、右上、右下、左下                    sorted_points = sort_rectangle_corners(points)                    return sorted_points                else:                    print(f"✗ 轮廓{i}: 非凸四边形")            else:                print(f"✗ 轮廓{i}: 对边比例不合理 {side1_ratio:.3f}/{side2_ratio:.3f}")        else:            print(f"✗ 轮廓{i}: {len(approx)}个顶点，非四边形")        print("未检测到合适的倾斜A4纸")    return Nonedef sort_rectangle_corners(points):    """    对矩形的四个角点进行排序    返回顺序：左上、右上、右下、左下    """    # 计算质心    center_x = np.mean(points[:, 0])    center_y = np.mean(points[:, 1])        # 按象限分类    top_left = None    top_right = None    bottom_right = None    bottom_left = None        for point in points:        x, y = point        if x < center_x and y < center_y:  # 左上            top_left = point        elif x > center_x and y < center_y:  # 右上            top_right = point        elif x > center_x and y > center_y:  # 右下            bottom_right = point        else:  # 左下            bottom_left = point        # 组织成顺序数组    sorted_corners = np.array([top_left, top_right, bottom_right, bottom_left])    return sorted_corners# 基于A4纸几何特征估算倾斜角度def estimate_tilt_angle_from_paper(corners):    """    基于A4纸几何特征估算倾斜角度    使用多种方法综合估算，返回最佳角度    corners: [左上, 右上, 右下, 左下] 四个角点    """    print("估算A4纸倾斜角度...")        if corners is None or len(corners) != 4:        print("角点数据无效")        return 0.0        top_left, top_right, bottom_right, bottom_left = corners        # 方法1: 基于A4纸标准比例分析    angle1 = estimate_angle_by_aspect_ratio(corners)        # 方法2: 基于边框线角度分析    angle2 = estimate_angle_by_edge_orientation(corners)        # 方法3: 基于对角线分析    angle3 = estimate_angle_by_diagonal_analysis(corners)        # 综合多种方法的结果    angles = [angle1, angle2, angle3]    valid_angles = [angle for angle in angles if angle is not None and 0 <= angle <= 90]        if not valid_angles:        print("所有角度估算方法都失败")        return 0.0        # 使用中位数作为最终结果（更鲁棒）    final_angle = np.median(valid_angles)        print(f"角度估算结果: 方法1={angle1:.1f}°, 方法2={angle2:.1f}°, 方法3={angle3:.1f}°")    print(f"最终角度: {final_angle:.1f}°")        return final_angledef estimate_angle_by_aspect_ratio(corners):    """方法1: 基于A4纸标准比例(√2:1)估算角度"""    try:        top_left, top_right, bottom_right, bottom_left = corners                # 计算当前矩形的宽度和高度        width = np.sqrt((top_right[0] - top_left[0])**2 + (top_right[1] - top_left[1])**2)        height = np.sqrt((bottom_left[0] - top_left[0])**2 + (bottom_left[1] - top_left[1])**2)                # 计算apparent aspect ratio        apparent_ratio = max(width, height) / min(width, height)        standard_a4_ratio = np.sqrt(2)  # A4纸标准比例 ≈ 1.414                # 如果apparent ratio小于标准比例，说明发生了透视收缩        if apparent_ratio < standard_a4_ratio:            # 通过几何关系反推角度: apparent_ratio = standard_ratio * cos(θ)            cos_theta = apparent_ratio / standard_a4_ratio            cos_theta = np.clip(cos_theta, 0, 1)  # 限制在合理范围内            theta = np.degrees(np.arccos(cos_theta))            print(f"比例法: apparent={apparent_ratio:.3f}, 标准={standard_a4_ratio:.3f}, 角度={theta:.1f}°")            return theta        else:            print(f"比例法: apparent ratio {apparent_ratio:.3f} >= 标准值，可能未倾斜")            return 0.0                except Exception as e:        print(f"比例法估算失败: {e}")        return Nonedef estimate_angle_by_edge_orientation(corners):    """方法2: 基于边框线与水平线的夹角"""    try:        top_left, top_right, bottom_right, bottom_left = corners                # 计算上边框线的角度        top_edge_angle = np.degrees(np.arctan2(top_right[1] - top_left[1],                                               top_right[0] - top_left[0]))                # 计算下边框线的角度        bottom_edge_angle = np.degrees(np.arctan2(bottom_right[1] - bottom_left[1],                                                  bottom_right[0] - bottom_left[0]))                # 取绝对值并限制在0-90度范围        top_angle = abs(top_edge_angle)        bottom_angle = abs(bottom_edge_angle)                # 使用两条边的平均角度        average_edge_angle = (top_angle + bottom_angle) / 2                # 这个角度反映了纸张相对于水平面的倾斜        print(f"边框法: 上边={top_angle:.1f}°, 下边={bottom_angle:.1f}°, 平均={average_edge_angle:.1f}°")        return average_edge_angle            except Exception as e:        print(f"边框法估算失败: {e}")        return Nonedef estimate_angle_by_diagonal_analysis(corners):    """方法3: 基于对角线长度比较估算角度"""    try:        top_left, top_right, bottom_right, bottom_left = corners                # 计算两条对角线的长度        diagonal1 = np.sqrt((bottom_right[0] - top_left[0])**2 +                            (bottom_right[1] - top_left[1])**2)        diagonal2 = np.sqrt((bottom_left[0] - top_right[0])**2 +                            (bottom_left[1] - top_right[1])**2)                # 对于标准矩形，两条对角线应该相等        # 倾斜时会产生差异        diagonal_ratio = min(diagonal1, diagonal2) / max(diagonal1, diagonal2)                # 基于对角线比例估算角度（经验公式）        if diagonal_ratio < 1.0:            # 角度与对角线比例的偏差相关            angle_factor = 1.0 - diagonal_ratio            estimated_angle = angle_factor * 45  # 经验系数                        print(f"对角线法: 比例={diagonal_ratio:.3f}, 估算角度={estimated_angle:.1f}°")            return estimated_angle        else:            print(f"对角线法: 比例={diagonal_ratio:.3f}, 未检测到明显倾斜")            return 0.0                except Exception as e:        print(f"对角线法估算失败: {e}")        return None# 透视矫正流水线def perspective_correction_pipeline(frame, corners, tilt_angle):    """    透视矫正流水线，将倾斜的A4纸矫正为正视图    返回矫正后的图像和新的像素-厘米转换比例    """    print(f"开始透视矫正，倾斜角度: {tilt_angle:.1f}°")        if corners is None or len(corners) != 4:        print("角点数据无效，无法进行透视矫正")        return frame, None        try:        # Step 1: 定义目标矩形（标准A4纸比例）        target_width = 600  # 目标宽度（像素）        target_height = int(target_width * np.sqrt(2))  # A4比例的高度                # 目标四个角点 (左上、右上、右下、左下)        dst_points = np.array([            [0, 0],                                    # 左上            [target_width, 0],                         # 右上              [target_width, target_height],             # 右下            [0, target_height]                         # 左下        ], dtype=np.float32)                # Step 2: 源图像的四个角点        src_points = corners.astype(np.float32)                # Step 3: 计算透视变换矩阵        perspective_matrix = cv2.getPerspectiveTransform(src_points, dst_points)                # Step 4: 执行透视变换        corrected_frame = cv2.warpPerspective(frame, perspective_matrix,                                             (target_width, target_height))                # Step 5: 计算新的像素-厘米转换比例        new_pixel_to_cm_ratio = calculate_corrected_pixel_ratio(corrected_frame, tilt_angle)                # Step 6: 验证矫正质量        correction_quality = evaluate_correction_quality(corrected_frame, target_width, target_height)                print(f"透视矫正完成: 目标尺寸{target_width}x{target_height}, 质量评估: {correction_quality}")        print(f"新的像素-厘米比例: {new_pixel_to_cm_ratio:.4f} cm/pixel")                return corrected_frame, new_pixel_to_cm_ratio            except Exception as e:        print(f"透视矫正失败: {e}")        return frame, Nonedef calculate_corrected_pixel_ratio(corrected_frame, tilt_angle):    """    计算矫正后图像的像素-厘米转换比例    基于A4纸标准尺寸: 21cm x 29.7cm    """    try:        frame_height, frame_width = corrected_frame.shape[:2]                # A4纸实际尺寸        A4_WIDTH_CM = 21.0        A4_HEIGHT_CM = 29.7                # 计算像素-厘米比例        width_ratio = A4_WIDTH_CM / frame_width        height_ratio = A4_HEIGHT_CM / frame_height                # 使用平均值作为最终比例        pixel_to_cm_ratio = (width_ratio + height_ratio) / 2                print(f"A4纸像素比例计算: 宽度={width_ratio:.4f}, 高度={height_ratio:.4f}")                return pixel_to_cm_ratio            except Exception as e:        print(f"计算像素比例失败: {e}")        return 0.05  # 默认值def evaluate_correction_quality(corrected_frame, target_width, target_height):    """    评估透视矫正的质量    检查矫正后的图像是否接近标准A4比例    """    try:        # 计算实际的长宽比        actual_ratio = target_height / target_width        expected_ratio = np.sqrt(2)  # A4标准比例                # 计算偏差        ratio_error = abs(actual_ratio - expected_ratio) / expected_ratio                # 质量评级        if ratio_error < 0.05:            quality = "优秀"        elif ratio_error < 0.10:            quality = "良好"        elif ratio_error < 0.20:            quality = "一般"        else:            quality = "较差"                print(f"矫正质量: 实际比例={actual_ratio:.3f}, 标准比例={expected_ratio:.3f}, 误差={ratio_error:.3f}")                return quality            except Exception as e:        print(f"质量评估失败: {e}")        return "未知"# 在矫正图像中检测内部图形def detect_shapes_in_corrected_image(corrected_frame, pixel_to_cm_ratio):    """    在透视矫正后的图像中检测内部图形    复用现有的图形检测算法，并应用新的像素-厘米比例    """    print("在矫正图像中检测内部图形...")        if corrected_frame is None or pixel_to_cm_ratio is None:        print("矫正图像或比例数据无效")        return []        try:        # Step 1: 图像预处理        gray_corrected = cv2.cvtColor(corrected_frame, cv2.COLOR_BGR2GRAY)        blurred = cv2.GaussianBlur(gray_corrected, (5, 5), 2)        _, binary_corrected = cv2.threshold(blurred, 127, 255, cv2.THRESH_BINARY)                # Step 2: 检测内部图形的"外边框"        # 在矫正后的图像中，寻找A4纸的内边框        corrected_rectangles = detect_corrected_inner_rectangles(binary_corrected)                if not corrected_rectangles:            print("在矫正图像中未找到内部矩形框")            return []                # Step 3: 检测内部图形        corrected_shapes = detect_inner_shapes_corrected(binary_corrected, corrected_rectangles, pixel_to_cm_ratio)                print(f"在矫正图像中检测到 {len(corrected_shapes)} 个内部图形")                return corrected_shapes            except Exception as e:        print(f"矫正图像中图形检测失败: {e}")        return []def detect_corrected_inner_rectangles(binary_corrected):    """    在矫正后的图像中检测内部的矩形边框    矫正后图形更规整，使用标准的矩形检测参数    """    contours, _ = cv2.findContours(binary_corrected, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)    rectangles = []        height, width = binary_corrected.shape    total_area = height * width        for contour in contours:        epsilon = 0.015 * cv2.arcLength(contour, True)        approx = cv2.approxPolyDP(contour, epsilon, True)                if len(approx) == 4:            rect = cv2.boundingRect(approx)            rect_width, rect_height = rect[2], rect[3]            area = rect_width * rect_height                        # 适应矫正后图像的面积过滤            min_area = total_area * 0.1  # 至少10%的图像面积            max_area = total_area * 0.9  # 最多90%的图像面积                        if min_area <= area <= max_area:                # 检查长宽比（矫正后应该更接近标准比例）                aspect_ratio = max(rect_width, rect_height) / min(rect_width, rect_height)                                if 1.0 <= aspect_ratio <= 2.5:  # 合理的矩形比例                    rectangles.append(approx)                    print(f"找到矫正图像内部矩形: {rect_width}x{rect_height}, 比例={aspect_ratio:.2f}")        return rectanglesdef detect_inner_shapes_corrected(binary_corrected, rectangles, pixel_to_cm_ratio):    """    在矫正图像的内部矩形中检测图形    复用现有逻辑但使用新的像素-厘米比例    """    all_shapes = []        if not rectangles:        print("没有找到内部矩形边框")        return all_shapes        # 使用第一个（通常也是最大的）矩形作为检测区域    target_rectangle = rectangles[0]        # 提取ROI区域    x, y, w, h = cv2.boundingRect(target_rectangle)    roi_binary = binary_corrected[y:y+h, x:x+w]        # 在ROI内查找轮廓    contours, _ = cv2.findContours(roi_binary, cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)        print(f"在矫正图像ROI内找到 {len(contours)} 个轮廓")        for i, contour in enumerate(contours):        area = cv2.contourArea(contour)                # 过滤过小的轮廓        if area < 100:            continue                    # 过滤边界轮廓        contour_bbox = cv2.boundingRect(contour)        margin = 5        if (contour_bbox[0] < margin or contour_bbox[1] < margin or            contour_bbox[0] + contour_bbox[2] > w - margin or            contour_bbox[1] + contour_bbox[3] > h - margin):            if area > w * h * 0.7:                continue                # 轮廓近似        epsilon = 0.04 * cv2.arcLength(contour, True)        approx = cv2.approxPolyDP(contour, epsilon, True)        vertices = len(approx)        perimeter = cv2.arcLength(contour, True)                # 调整坐标到原图        approx_adjusted = approx + [x, y]                # 三角形检测        if vertices == 3:            points = approx.reshape(-1, 2)            side_lengths = []            for j in range(3):                p1 = points[j]                p2 = points[(j + 1) % 3]                length = np.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)                side_lengths.append(length)                        min_side_pixels = int(min(side_lengths))            min_side_cm = min_side_pixels * pixel_to_cm_ratio                        all_shapes.append(('triangle', approx_adjusted, min_side_pixels, min_side_cm))            print(f"检测到三角形: 最短边长{min_side_pixels}像素 ({min_side_cm:.2f}cm)")            continue                # 正方形检测        if vertices == 4:            rect_shape = cv2.boundingRect(approx)            width_rect, height_rect = rect_shape[2], rect_shape[3]            aspect_ratio = max(width_rect, height_rect) / min(width_rect, height_rect)                        if 0.7 <= aspect_ratio <= 1.4:  # 正方形                points = approx.reshape(-1, 2)                side_lengths = []                for j in range(4):                    p1 = points[j]                    p2 = points[(j + 1) % 4]                    length = np.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)                    side_lengths.append(length)                                min_side_pixels = int(min(side_lengths))                min_side_cm = min_side_pixels * pixel_to_cm_ratio                                all_shapes.append(('square', approx_adjusted, min_side_pixels, min_side_cm))                print(f"检测到正方形: 最短边长{min_side_pixels}像素 ({min_side_cm:.2f}cm)")                continue                # 圆形检测        if vertices >= 5:            circularity = 4 * np.pi * area / (perimeter * perimeter)            if 0.3 < circularity < 2.0:                rect_contour = cv2.boundingRect(contour)                center_x = rect_contour[0] + rect_contour[2] // 2 + x                center_y = rect_contour[1] + rect_contour[3] // 2 + y                center = (int(center_x), int(center_y))                                radius = int(min(rect_contour[2], rect_contour[3]) / 2)                diameter_pixels = radius * 2                diameter_cm = diameter_pixels * pixel_to_cm_ratio                                contour_adjusted = contour + [x, y]                                all_shapes.append(('circle', center, radius, diameter_pixels, diameter_cm, contour_adjusted))                print(f"检测到圆形: 直径{diameter_pixels}像素 ({diameter_cm:.2f}cm)")                continue        return all_shapes# 显示倾斜矫正结果的可视化函数def show_tilt_correction_results(original_frame, corrected_frame, corners, tilt_angle, detected_shapes):    """    显示倾斜矫正的完整结果，包括多窗口对比显示    """    print("生成可视化结果...")        try:        # 1. 原始图像：显示检测到的倾斜A4纸边框        original_display = original_frame.copy()        if corners is not None:            # 绘制检测到的四个角点            for i, corner in enumerate(corners):                cv2.circle(original_display, tuple(corner.astype(int)), 8, (0, 255, 0), -1)                cv2.putText(original_display, str(i+1),                            (corner[0]+10, corner[1]-10),                            cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 255, 0), 2)                        # 绘制倾斜的A4纸轮廓            cv2.drawContours(original_display, [corners.astype(int)], -1, (0, 255, 255), 3)                        # 显示角度信息            cv2.putText(original_display, f"Tilt Angle: {tilt_angle:.1f} degrees",                        (20, 30), cv2.FONT_HERSHEY_SIMPLEX, 1.0, (255, 255, 0), 2)                        cv2.putText(original_display, f"Detected tilted A4 paper",                        (20, 70), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (255, 255, 255), 2)                # 2. 矫正后图像：显示透视矫正结果        corrected_display = corrected_frame.copy() if corrected_frame is not None else np.zeros((600, 600, 3), dtype=np.uint8)                if corrected_frame is not None:            cv2.putText(corrected_display, "Perspective Corrected",                        (20, 30), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 255, 0), 2)                        cv2.putText(corrected_display, f"Standard A4 view",                        (20, 60), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 255), 2)                # 3. 图形检测结果：在矫正图像上显示检测到的图形        shapes_display = corrected_display.copy()                if detected_shapes:            cv2.putText(shapes_display, f"Detected Shapes: {len(detected_shapes)}",                        (20, 30), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 255, 255), 2)                        # 绘制检测到的图形            for i, shape_data in enumerate(detected_shapes):                shape_type = shape_data[0]                                if shape_type == 'circle':                    _, center, radius, diameter_pixels, diameter_cm, contour_adjusted = shape_data                    cv2.drawContours(shapes_display, [contour_adjusted], -1, (255, 0, 0), 2)                    cv2.circle(shapes_display, center, 3, (255, 0, 0), -1)                    cv2.putText(shapes_display, f"Circle D:{diameter_cm:.1f}cm",                                (center[0]-50, center[1]-radius-15),                                cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 0, 0), 2)                                elif shape_type == 'square':                    _, contour, side_pixels, side_cm = shape_data                    cv2.drawContours(shapes_display, [contour], -1, (0, 0, 255), 2)                    # 绘制角点                    for point in contour:                        cv2.circle(shapes_display, tuple(point[0]), 3, (0, 255, 0), -1)                    # 显示边长                    rect_bbox = cv2.boundingRect(contour)                    cv2.putText(shapes_display, f"Square L:{side_cm:.1f}cm",                                (rect_bbox[0], rect_bbox[1]-10),                                cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 0, 255), 2)                                elif shape_type == 'triangle':                    _, contour, side_pixels, side_cm = shape_data                    cv2.drawContours(shapes_display, [contour], -1, (255, 0, 255), 2)                    # 绘制角点                    for point in contour:                        cv2.circle(shapes_display, tuple(point[0]), 3, (0, 255, 0), -1)                    # 显示边长                    rect_bbox = cv2.boundingRect(contour)                    cv2.putText(shapes_display, f"Triangle L:{side_cm:.1f}cm",                                (rect_bbox[0], rect_bbox[1]-10),                                cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 0, 255), 2)                # 4. 对比显示：将原图和矫正图放在一起        # 调整图像尺寸以便并排显示        display_height = 400                # 原图缩放        original_aspect = original_display.shape[1] / original_display.shape[0]        original_width = int(display_height * original_aspect)        original_resized = cv2.resize(original_display, (original_width, display_height))                # 矫正图缩放        if corrected_frame is not None:            corrected_aspect = corrected_display.shape[1] / corrected_display.shape[0]            corrected_width = int(display_height * corrected_aspect)            corrected_resized = cv2.resize(corrected_display, (corrected_width, display_height))            shapes_resized = cv2.resize(shapes_display, (corrected_width, display_height))        else:            corrected_width = original_width            corrected_resized = np.zeros((display_height, corrected_width, 3), dtype=np.uint8)            shapes_resized = corrected_resized.copy()                # 创建对比图像        gap = 10        total_width = original_width + corrected_width * 2 + gap * 3        comparison = np.zeros((display_height, total_width, 3), dtype=np.uint8)                # 放置原图        comparison[:, :original_width] = original_resized                # 放置矫正图        start_x = original_width + gap        comparison[:, start_x:start_x+corrected_width] = corrected_resized                # 放置图形检测结果        start_x = original_width + corrected_width + gap * 2        comparison[:, start_x:start_x+corrected_width] = shapes_resized                # 添加标题        cv2.putText(comparison, "Original (Tilted)", (20, display_height-20),                    cv2.FONT_HERSHEY_SIMPLEX, 0.7, (255, 255, 255), 2)                cv2.putText(comparison, "Corrected", (original_width + gap + 20, display_height-20),                    cv2.FONT_HERSHEY_SIMPLEX, 0.7, (255, 255, 255), 2)                cv2.putText(comparison, "Shapes Detected", (original_width + corrected_width + gap * 2 + 20, display_height-20),                    cv2.FONT_HERSHEY_SIMPLEX, 0.7, (255, 255, 255), 2)                # 显示所有窗口        cv2.imshow("Tilt Correction - Original", original_display)        cv2.imshow("Tilt Correction - Corrected", corrected_display)        cv2.imshow("Tilt Correction - Shapes", shapes_display)        cv2.imshow("Tilt Correction - Comparison", comparison)                return comparison            except Exception as e:        print(f"可视化显示失败: {e}")        return original_frame# 显示基础图形检测处理步骤（简化版，无数字识别）def show_basic_shapes_detection_steps(frame, gray, binary, rectangles, inner_shapes):    """    显示基础图形检测的处理步骤，不包含数字识别功能    步骤1: 原始图像    步骤2: 矩形检测结果    步骤3: ROI提取    步骤4: 二值化结果    步骤5: 基础图形分类    """    if not rectangles:        return frame        # 确定目标矩形（内边缘或单个矩形）    if len(rectangles) >= 2:        rectangles_with_area = [(rect, cv2.contourArea(rect)) for rect in rectangles]        rectangles_with_area.sort(key=lambda x: x[1])        target_rectangle = rectangles_with_area[0][0]    else:        target_rectangle = rectangles[0]        x, y, w, h = cv2.boundingRect(target_rectangle)    roi_binary = binary[y:y+h, x:x+w]    roi_gray = gray[y:y+h, x:x+w]        # 步骤1: 原始图像    step1 = cv2.resize(frame, (320, 240))        # 步骤2: 矩形检测结果    step2_img = frame.copy()    for rect in rectangles:        cv2.drawContours(step2_img, [rect], -1, (0, 255, 0), 1)    # 高亮目标矩形    cv2.drawContours(step2_img, [target_rectangle], -1, (0, 255, 255), 2)    step2 = cv2.resize(step2_img, (320, 240))        # 步骤3: ROI提取    step3 = cv2.resize(cv2.cvtColor(roi_gray, cv2.COLOR_GRAY2BGR), (320, 240))        # 步骤4: 二值化结果    step4_img = cv2.cvtColor(roi_binary, cv2.COLOR_GRAY2BGR)    step4 = cv2.resize(step4_img, (320, 240))        # 步骤5: 基础图形分类（无数字识别）    contours, _ = cv2.findContours(roi_binary, cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)    step5_img = cv2.cvtColor(roi_gray, cv2.COLOR_GRAY2BGR)    for contour in contours:        area = cv2.contourArea(contour)        if area < 100:            continue                contour_bbox = cv2.boundingRect(contour)        margin = 5        if (contour_bbox[0] < margin or contour_bbox[1] < margin or            contour_bbox[0] + contour_bbox[2] > w - margin or            contour_bbox[1] + contour_bbox[3] > h - margin):            continue                epsilon = 0.04 * cv2.arcLength(contour, True)  # 与检测函数保持一致        approx = cv2.approxPolyDP(contour, epsilon, True)        vertices = len(approx)        perimeter = cv2.arcLength(contour, True)                # 根据形状类型用不同颜色绘制        if vertices > 6:            circularity = 4 * np.pi * area / (perimeter * perimeter)            if 0.3 < circularity < 2.0:                cv2.drawContours(step5_img, [contour], -1, (255, 0, 0), 1)  # 蓝色圆形            else:                cv2.drawContours(step5_img, [contour], -1, (0, 165, 255), 1)  # 橙色多边形        elif vertices == 3:            cv2.drawContours(step5_img, [contour], -1, (255, 0, 255), 1)  # 紫色三角形        elif vertices == 4:            rect_shape = cv2.boundingRect(approx)            width_rect, height_rect = rect_shape[2], rect_shape[3]            aspect_ratio = max(width_rect, height_rect) / min(width_rect, height_rect)            if 0.7 <= aspect_ratio <= 1.4:                cv2.drawContours(step5_img, [contour], -1, (0, 0, 255), 1)  # 红色正方形            else:                cv2.drawContours(step5_img, [contour], -1, (0, 165, 255), 1)  # 橙色多边形        else:            cv2.drawContours(step5_img, [contour], -1, (0, 165, 255), 1)  # 橙色多边形        step5 = cv2.resize(step5_img, (320, 240))        # 步骤6: 最终结果    step6 = frame.copy()    for rect in rectangles:        cv2.drawContours(step6, [rect], -1, (0, 255, 0), 1)        # 绘制内部图形（无数字识别信息）    for shape_data in inner_shapes:        shape_type = shape_data[0]        if shape_type == 'circle':            if len(shape_data) >= 6:                _, center, radius, diameter_pixels, diameter_cm, contour_adjusted = shape_data                cv2.drawContours(step6, [contour_adjusted], -1, (255, 0, 0), 1)                cv2.circle(step6, center, 2, (255, 0, 0), -1)            else:                _, center, radius, diameter_pixels = shape_data                cv2.circle(step6, center, radius, (255, 0, 0), 1)                cv2.circle(step6, center, 2, (255, 0, 0), -1)        elif shape_type == 'square':            if len(shape_data) >= 4:                _, contour, side_pixels, side_cm = shape_data            else:                _, contour, side_pixels = shape_data            cv2.drawContours(step6, [contour], -1, (0, 0, 255), 1)        elif shape_type == 'triangle':            if len(shape_data) >= 4:                _, contour, side_pixels, side_cm = shape_data            else:                _, contour, side_pixels = shape_data            cv2.drawContours(step6, [contour], -1, (255, 0, 255), 1)        step6 = cv2.resize(step6, (320, 240))        # 拼接所有步骤（2行3列布局）    # 第一行：原图、矩形检测、ROI提取    top_row = np.hstack((step1, step2, step3))    # 第二行：二值化、形状分类、最终结果    bottom_row = np.hstack((step4, step5, step6))        combined = np.vstack((top_row, bottom_row))        # 添加步骤标题    cv2.putText(combined, "1.Original", (10, 20), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 2)    cv2.putText(combined, "2.Rectangle Detection", (330, 20), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 2)    cv2.putText(combined, "3.ROI Extraction", (650, 20), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 2)    cv2.putText(combined, "4.Binarization", (10, 260), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 2)    cv2.putText(combined, "5.Basic Shape Classification", (330, 260), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 2)    cv2.putText(combined, "6.Final Result", (650, 260), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 2)        return combined# 加载YOLOv5模型print("正在加载YOLOv5数字识别模型...")try:    WEIGHTS_PATH = "/home/forever/yolov5-master/runs/train/exp2/weights/best.pt"    DATA_YAML = "data/coco128.yaml"  # 根据实际数据集修改    DEVICE = ""        yolo_model, yolo_device, yolo_imgsz, yolo_class_names = load_yolov5_model(WEIGHTS_PATH, DATA_YAML, DEVICE)    print(f"YOLOv5模型加载成功！设备：{yolo_device}，训练尺寸：{yolo_imgsz}×{yolo_imgsz}")    print(f"可识别的类别：{yolo_class_names}")except Exception as e:    print(f"YOLOv5模型加载失败：{e}")    print("将继续运行但数字识别功能不可用")    yolo_model = None# 创建一个VideoCapture对象，并打开系统默认的摄像头（也可以打开视频或者指定的设备）cap = cv2.VideoCapture(0)# 不能打开摄像头if not cap.isOpened():    raise RuntimeError('Could not open camera.')# 设置帧宽和高度cap.set(cv2.CAP_PROP_FRAME_WIDTH, width)cap.set(cv2.CAP_PROP_FRAME_HEIGHT, height)while(cap.isOpened()):    # 返回两个参数，ret表示是否正常打开，frame是图像数组,一帧    ret,frame  = cap.read()    if ret:        # 直接显示原始画面        cv2.putText(frame, "Live Camera - Press: 'r'=shapes, 'n'=digit labels, 's'=edge, 't'=tilt",                    (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 255), 2)        cv2.imshow("Live Camera View", frame)    # 延迟1ms，并根据键盘输入返回值val，是板卡接的键盘    val = cv2.waitKey(1) & 0xFF    # 捕获到键盘输入's',开始边缘检测和多边形逼近    if val == ord('s'):        print("=======================================")        print("开始边缘检测和多边形逼近分析...")                # 直接使用原始帧进行处理        gray, binary = preprocess_frame(frame)                # 检测矩形边框（与r键保持一致）        rectangles = detect_rectangles(binary)                if rectangles:            # 计算像素到厘米的转换比例（与r键保持一致）            pixel_to_cm_ratio = calculate_pixel_to_cm_ratio_inner(rectangles)                        # 进行边缘检测和多边形逼近            detected_polygons = detect_internal_edges_and_polygons(gray, binary, rectangles, pixel_to_cm_ratio)                        if detected_polygons:                # 显示结果                result_image = frame.copy()                                # 绘制矩形轮廓（绿色）                for rect in rectangles:                    cv2.drawContours(result_image, [rect], -1, (0, 255, 0), 1)                                print(f"检测到 {len(detected_polygons)} 个内部多边形")                                # 绘制每个检测到的多边形                colors = [(255, 0, 0), (0, 255, 255), (255, 0, 255), (255, 255, 0), (0, 165, 255), (128, 0, 128)]                for i, polygon in enumerate(detected_polygons):                    color = colors[i % len(colors)]                    contour = polygon['contour']                    vertices = polygon['vertices']                    avg_side_pixels = polygon['avg_side_pixels']                    avg_side_cm = polygon['avg_side_cm']                    convex_corners = polygon.get('convex_corners', [])                    concave_corners = polygon.get('concave_corners', [])                    min_edge_pair = polygon.get('min_edge_pair', None)                    min_edge_length_cm = polygon.get('min_edge_length_cm', 0)                                        # 绘制多边形轮廓                    cv2.drawContours(result_image, [contour], -1, color, 1)                                        # 绘制普通顶点（灰色）                    for j, point in enumerate(contour):                        center = tuple(point[0])                        cv2.circle(result_image, center, 2, (128, 128, 128), -1)  # 灰色实心圆                        cv2.circle(result_image, center, 3, (255, 255, 255), 1)  # 白色外圈                        # 添加顶点编号                        cv2.putText(result_image, str(j+1),                                   (center[0]+6, center[1]-6), cv2.FONT_HERSHEY_SIMPLEX, 0.3, (255, 255, 255), 1)                                        # 绘制凸角点（绿色圆点）                    for (corner, idx) in convex_corners:                        cv2.circle(result_image, corner, 3, (0, 255, 0), -1)  # 绿色实心圆                        cv2.circle(result_image, corner, 4, (255, 255, 255), 1)  # 白色外圈                        cv2.putText(result_image, "C",                                   (corner[0]+8, corner[1]-8), cv2.FONT_HERSHEY_SIMPLEX, 0.4, (0, 255, 0), 2)                                        # 绘制凹角点（红色圆点）                    for (corner, idx) in concave_corners:                        cv2.circle(result_image, corner, 3, (0, 0, 255), -1)  # 红色实心圆                        cv2.circle(result_image, corner, 4, (255, 255, 255), 1)  # 白色外圈                        cv2.putText(result_image, "V",                                   (corner[0]+8, corner[1]-8), cv2.FONT_HERSHEY_SIMPLEX, 0.4, (0, 0, 255), 2)                                        # 绘制最短边长（如果存在）                    if min_edge_pair:                        p1, p2 = min_edge_pair                        # 绘制最短边长的两个端点（特殊标记）                        cv2.circle(result_image, p1, 4, (255, 255, 0), -1)  # 黄色实心圆                        cv2.circle(result_image, p1, 5, (0, 0, 0), 1)  # 黑色外圈                        cv2.circle(result_image, p2, 4, (255, 255, 0), -1)  # 黄色实心圆                        cv2.circle(result_image, p2, 5, (0, 0, 0), 1)  # 黑色外圈                                                # 绘制连线                        cv2.line(result_image, p1, p2, (255, 255, 0), 2)   # 黄色线                        cv2.line(result_image, p1, p2, (0, 0, 0), 1)       # 黑色细线在中间                                                # 显示长度信息                        mid_point = ((p1[0] + p2[0]) // 2, (p1[1] + p2[1]) // 2)                        text = f"Min:{min_edge_length_cm:.1f}cm"                        # 添加黑色背景让文字更清晰                        (text_width, text_height), _ = cv2.getTextSize(text, cv2.FONT_HERSHEY_SIMPLEX, 0.4, 1)                        cv2.rectangle(result_image,                                     (mid_point[0] - text_width//2 - 2, mid_point[1] - text_height - 2),                                    (mid_point[0] + text_width//2 + 2, mid_point[1] + 2),                                    (0, 0, 0), -1)  # 黑色背景                        cv2.putText(result_image, text,                                    (mid_point[0] - text_width//2, mid_point[1]),                                   cv2.FONT_HERSHEY_SIMPLEX, 0.4, (255, 255, 0), 1)                                        # 添加标签                    rect_bbox = cv2.boundingRect(contour)                    cv2.putText(result_image, f"P{i+1}({vertices}v): Conv:{len(convex_corners)} Conc:{len(concave_corners)}",                               (rect_bbox[0], rect_bbox[1]-10),                               cv2.FONT_HERSHEY_SIMPLEX, 0.5, color, 2)                                        print(f"多边形{i+1}: {vertices}个顶点, 平均边长 {avg_side_pixels}像素 ({avg_side_cm:.2f}cm)")                    print(f"  凸角点: {len(convex_corners)}个, 凹角点: {len(concave_corners)}个")                    if min_edge_pair:                        print(f"  最短凸角点边长: {min_edge_length_cm:.2f}cm")                                cv2.imshow("Edge Detection and Polygon Approximation", result_image)            else:                print("未检测到内部多边形")        else:            print("未检测到矩形边框，无法进行边缘检测")                print("=======================================")        # 捕获到键盘输入'r',开始基础图形检测（无数字识别）    elif val == ord('r'):        print("=======================================")        print("开始基础图形检测分析（圆形、正方形、三角形）...")                # Step 1: 直接使用原始帧进行处理        gray, binary = preprocess_frame(frame)                # Step 2: 检测矩形边框        rectangles = detect_rectangles(binary)                if rectangles:            # Step 3: 检测内部图形（无数字识别）            inner_shapes = detect_inner_shapes(binary, rectangles)                        # Step 4: 显示基础图形检测处理步骤（简化版）            steps_image = show_basic_shapes_detection_steps(frame, gray, binary, rectangles, inner_shapes)            cv2.imshow("Basic Shape Detection Steps", steps_image)                        # Step 6: 绘制最终结果            result_image = frame.copy()                        # 绘制矩形轮廓（绿色）            for rect in rectangles:                cv2.drawContours(result_image, [rect], -1, (0, 255, 0), 1)                        # 绘制内部图形            for shape_data in inner_shapes:                shape_type = shape_data[0]                                if shape_type == 'circle':                    _, center, radius, diameter_pixels, diameter_cm, contour_adjusted = shape_data                    # 使用轮廓绘制更准确的圆形（蓝色）                    cv2.drawContours(result_image, [contour_adjusted], -1, (255, 0, 0), 1)                    cv2.circle(result_image, center, 2, (255, 0, 0), -1)  # 中心点                    # 显示直径信息                    cv2.putText(result_image, f"Circle D:{diameter_pixels}px ({diameter_cm:.1f}cm)",                               (center[0]-80, center[1]-radius-10),                               cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 0), 2)                                elif shape_type == 'square':                    _, contour, side_pixels, side_cm = shape_data                    # 绘制正方形（红色）                    cv2.drawContours(result_image, [contour], -1, (0, 0, 255), 1)                    # 绘制顶点（绿色圆点）                    for point in contour:                        center = tuple(point[0])                        cv2.circle(result_image, center, 3, (0, 255, 0), -1)  # 绿色实心圆                        cv2.circle(result_image, center, 4, (255, 255, 255), 1)  # 白色外圈                    # 显示边长信息和顶点数                    rect_bbox = cv2.boundingRect(contour)                    cv2.putText(result_image, f"Square({len(contour)}v) Avg:{side_pixels}px ({side_cm:.1f}cm)",                               (rect_bbox[0], rect_bbox[1]-10),                               cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 0), 2)                                elif shape_type == 'triangle':                    _, contour, side_pixels, side_cm = shape_data                    # 绘制三角形（紫色）                    cv2.drawContours(result_image, [contour], -1, (255, 0, 255), 1)                    # 绘制顶点（绿色圆点）                    for point in contour:                        center = tuple(point[0])                        cv2.circle(result_image, center, 3, (0, 255, 0), -1)  # 绿色实心圆                        cv2.circle(result_image, center, 4, (255, 255, 255), 1)  # 白色外圈                    # 显示边长信息和顶点数                    rect_bbox = cv2.boundingRect(contour)                    cv2.putText(result_image, f"Triangle({len(contour)}v) Avg:{side_pixels}px ({side_cm:.1f}cm)",                               (rect_bbox[0], rect_bbox[1]-10),                               cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 0), 2)                                elif shape_type == 'polygon':                    _, contour, vertices, side_pixels, side_cm = shape_data                    # 绘制多边形轮廓（橙色）                    cv2.drawContours(result_image, [contour], -1, (0, 165, 255), 1)                                        # 绘制角点（绿色圆点）                    for point in contour:                        center = tuple(point[0])                        cv2.circle(result_image, center, 5, (0, 255, 0), -1)  # 绿色实心圆                        cv2.circle(result_image, center, 6, (255, 255, 255), 1)  # 白色外圈                                        # 显示信息和实际顶点数                    rect_bbox = cv2.boundingRect(contour)                    cv2.putText(result_image, f"Polygon({len(contour)}v) Max:{side_pixels}px ({side_cm:.1f}cm)",                               (rect_bbox[0], rect_bbox[1]-10),                               cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 0), 2)                        cv2.imshow("Basic Shape Detection Result", result_image)                        # Step 7: 打印检测信息            print(f"检测到 {len(rectangles)} 个矩形边框")            print(f"检测到 {len(inner_shapes)} 个内部图形")                        for i, shape_data in enumerate(inner_shapes):                shape_type = shape_data[0]                if shape_type == 'circle':                    _, center, radius, diameter_pixels, diameter_cm, contour_adjusted = shape_data                    print(f"图形{i+1}: 圆形 - 直径 {diameter_pixels}像素 ({diameter_cm:.2f}cm), 中心{center}")                elif shape_type == 'square':                    _, contour, side_pixels, side_cm = shape_data                    print(f"图形{i+1}: 正方形 - 平均边长 {side_pixels}像素 ({side_cm:.2f}cm)")                elif shape_type == 'triangle':                    _, contour, side_pixels, side_cm = shape_data                    print(f"图形{i+1}: 三角形 - 平均边长 {side_pixels}像素 ({side_cm:.2f}cm)")                elif shape_type == 'polygon':                    _, contour, vertices, side_pixels, side_cm = shape_data                    print(f"图形{i+1}: 多边形({vertices}个顶点) - 最长边长 {side_pixels}像素 ({side_cm:.2f}cm)")        else:            print("未检测到矩形边框，无法进行基础图形检测")                print("=======================================")        num += 1    # 捕获到键盘输入't',开始倾斜目标物检测和透视矫正    elif val == ord('t'):        print("=======================================")        print("开始倾斜目标物检测和透视矫正分析...")                # Step 1: 图像预处理        gray, binary = preprocess_frame(frame)                # Step 2: 检测倾斜的A4纸边框        tilted_corners = detect_tilted_a4_paper(binary)                if tilted_corners is not None:            # Step 3: 估算倾斜角度            tilt_angle = estimate_tilt_angle_from_paper(tilted_corners)                        # Step 4: 透视矫正            corrected_frame, pixel_to_cm_ratio = perspective_correction_pipeline(                frame, tilted_corners, tilt_angle)                        if corrected_frame is not None and pixel_to_cm_ratio is not None:                # Step 5: 在矫正图像中检测内部图形                detected_shapes = detect_shapes_in_corrected_image(corrected_frame, pixel_to_cm_ratio)                                # Step 6: 显示可视化结果                show_tilt_correction_results(frame, corrected_frame, tilted_corners,                                            tilt_angle, detected_shapes)                                # Step 7: 打印检测结果                print(f"倾斜角度: {tilt_angle:.1f}°")                print(f"透视矫正: 成功")                print(f"新像素比例: {pixel_to_cm_ratio:.4f} cm/pixel")                print(f"检测到内部图形: {len(detected_shapes)}个")                                for i, shape_data in enumerate(detected_shapes):                    shape_type = shape_data[0]                    if shape_type == 'circle':                        _, center, radius, diameter_pixels, diameter_cm, contour_adjusted = shape_data                        print(f"图形{i+1}: 圆形 - 直径 {diameter_cm:.2f}cm")                    elif shape_type == 'square':                        _, contour, side_pixels, side_cm = shape_data                        print(f"图形{i+1}: 正方形 - 边长 {side_cm:.2f}cm")                    elif shape_type == 'triangle':                        _, contour, side_pixels, side_cm = shape_data                        print(f"图形{i+1}: 三角形 - 最短边长 {side_cm:.2f}cm")            else:                print("透视矫正失败")        else:            print("未检测到倾斜的A4纸边框")                print("=======================================")    # 捕获到键盘输入'n',开始YOLOv5数字标号识别功能    elif val == ord('n'):        print("=======================================")        print("开始YOLOv5数字标号识别功能分析（包含基础图形检测）...")                if yolo_model is None:            print("YOLOv5模型未加载，无法进行数字识别")            print("=======================================")            continue                # Step 1: 直接使用原始帧进行处理        gray, binary = preprocess_frame(frame)                # Step 2: 检测矩形边框        rectangles = detect_rectangles(binary)                if rectangles:            # Step 3: 检测内部基础图形（正方形、圆形、三角形）            inner_shapes = detect_inner_shapes(binary, rectangles)                        # Step 4: 使用YOLOv5检测数字标号            digit_results = detect_digits_with_yolo(frame)                        # Step 5: 将数字标号与正方形进行关联            associated_squares = associate_digit_labels_with_squares(inner_shapes, digit_results)                        # Step 6: 绘制最终结果            result_image = frame.copy()                        # 绘制矩形轮廓（绿色）            for rect in rectangles:                cv2.drawContours(result_image, [rect], -1, (0, 255, 0), 1)                        # 绘制YOLOv5检测到的数字（蓝色框）            for digit_value, confidence, center, bbox in digit_results:                x1, y1, x2, y2 = bbox                cv2.rectangle(result_image, (x1, y1), (x2, y2), (255, 0, 0), 2)                cv2.putText(result_image, f"Digit:{digit_value}({confidence:.2f})",                            (x1, y1-10), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 0, 0), 2)                        # 绘制关联后的正方形结果            for square_contour, side_pixels, side_cm, digit_label, confidence in associated_squares:                if digit_label is not None:                    # 有数字标号的正方形用橙色绘制                    cv2.drawContours(result_image, [square_contour], -1, (0, 165, 255), 2)                    # 显示：标号: 边长                    rect_bbox = cv2.boundingRect(square_contour)                    text = f"Label {digit_label}: {side_cm:.1f}cm"                    cv2.putText(result_image, text,                               (rect_bbox[0], rect_bbox[1]-10),                               cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 165, 255), 2)                else:                    # 无数字标号的正方形用红色绘制                    cv2.drawContours(result_image, [square_contour], -1, (0, 0, 255), 1)                    rect_bbox = cv2.boundingRect(square_contour)                    cv2.putText(result_image, f"No Label: {side_cm:.1f}cm",                               (rect_bbox[0], rect_bbox[1]-10),                               cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 0, 255), 2)                        # 绘制其他图形（非正方形）            for shape_data in inner_shapes:                shape_type = shape_data[0]                                if shape_type == 'circle':                    _, center, radius, diameter_pixels, diameter_cm, contour_adjusted = shape_data                    # 使用轮廓绘制更准确的圆形（蓝色）                    cv2.drawContours(result_image, [contour_adjusted], -1, (255, 0, 0), 1)                    cv2.circle(result_image, center, 2, (255, 0, 0), -1)  # 中心点                    # 显示直径信息                    cv2.putText(result_image, f"Circle D:{diameter_pixels}px ({diameter_cm:.1f}cm)",                               (center[0]-80, center[1]-radius-10),                               cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 0), 2)                                elif shape_type == 'square':                    _, contour, side_pixels, side_cm = shape_data                    # 绘制正方形（红色）                    cv2.drawContours(result_image, [contour], -1, (0, 0, 255), 1)                    # 绘制顶点（绿色圆点）                    for point in contour:                        center = tuple(point[0])                        cv2.circle(result_image, center, 3, (0, 255, 0), -1)  # 绿色实心圆                        cv2.circle(result_image, center, 4, (255, 255, 255), 1)  # 白色外圈                    # 显示边长信息和顶点数                    rect_bbox = cv2.boundingRect(contour)                    cv2.putText(result_image, f"Square({len(contour)}v) Min:{side_pixels}px ({side_cm:.1f}cm)",                               (rect_bbox[0], rect_bbox[1]-10),                               cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 0), 2)                                elif shape_type == 'triangle':                    _, contour, side_pixels, side_cm = shape_data                    # 绘制三角形（紫色）                    cv2.drawContours(result_image, [contour], -1, (255, 0, 255), 1)                    # 绘制顶点（绿色圆点）                    for point in contour:                        center = tuple(point[0])                        cv2.circle(result_image, center, 3, (0, 255, 0), -1)  # 绿色实心圆                        cv2.circle(result_image, center, 4, (255, 255, 255), 1)  # 白色外圈                    # 显示边长信息和顶点数                    rect_bbox = cv2.boundingRect(contour)                    cv2.putText(result_image, f"Triangle({len(contour)}v) Min:{side_pixels}px ({side_cm:.1f}cm)",                               (rect_bbox[0], rect_bbox[1]-10),                               cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 0), 2)                                elif shape_type == 'polygon':                    _, contour, vertices, side_pixels, side_cm = shape_data                    # 绘制多边形轮廓（橙色）                    cv2.drawContours(result_image, [contour], -1, (0, 165, 255), 1)                                        # 绘制角点（绿色圆点）                    for point in contour:                        center = tuple(point[0])                        cv2.circle(result_image, center, 5, (0, 255, 0), -1)  # 绿色实心圆                        cv2.circle(result_image, center, 6, (255, 255, 255), 1)  # 白色外圈                                        # 显示信息和实际顶点数                    rect_bbox = cv2.boundingRect(contour)                    cv2.putText(result_image, f"Polygon({len(contour)}v) Max:{side_pixels}px ({side_cm:.1f}cm)",                               (rect_bbox[0], rect_bbox[1]-10),                               cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 0), 2)                        cv2.imshow("YOLOv5 Digit Label Recognition Result", result_image)                        # Step 7: 打印检测信息            print(f"检测到 {len(rectangles)} 个矩形边框")            print(f"检测到 {len(inner_shapes)} 个内部图形")            print(f"YOLOv5检测到 {len(digit_results)} 个数字")            print(f"成功关联 {len([s for s in associated_squares if s[3] is not None])} 个带标号的正方形")                        # 打印关联结果            for i, (square_contour, side_pixels, side_cm, digit_label, confidence) in enumerate(associated_squares):                if digit_label is not None:                    print(f"正方形{i+1}: 标号{digit_label} - 边长{side_cm:.2f}cm (置信度{confidence:.3f})")                else:                    print(f"正方形{i+1}: 无标号 - 边长{side_cm:.2f}cm")                        # 打印其他图形            for i, shape_data in enumerate(inner_shapes):                shape_type = shape_data[0]                if shape_type == 'circle':                    _, center, radius, diameter_pixels, diameter_cm, contour_adjusted = shape_data                    print(f"其他图形{i+1}: 圆形 - 直径 {diameter_cm:.2f}cm")                elif shape_type == 'triangle':                    _, contour, side_pixels, side_cm = shape_data                    print(f"其他图形{i+1}: 三角形 - 边长 {side_cm:.2f}cm")        else:            print("未检测到矩形边框，无法进行数字标号识别")                print("=======================================")        num += 1    # 若检测到按键 'q'，退出，是板卡接的键盘    if val == ord('q'):        break# 释放摄像头cap.release()# 关闭窗口cv2.destroyAllWindows()